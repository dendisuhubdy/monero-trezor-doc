\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage[margin=3cm]{geometry}
\usepackage{cite}
\usepackage{url}
\usepackage[breaklinks=true]{hyperref}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[toc,page]{appendix}
\usepackage[british,UKenglish,USenglish,american]{babel}

% TODO packages
% https://tex.stackexchange.com/questions/9796/how-to-add-todo-notes
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%opening
\title{Monero wallet Trezor integration draft v0.2}
\author{Du\v{s}an Klinec \\{dusan.klinec@gmail.com}}


\begin{document}
	
\maketitle

\begin{abstract}
	Design draft of the Monero integration to the Trezor environment and required in Monero codebase changes.
\end{abstract}

\section{Introduction}
Here follows the basic description of the Monero system, environment, and challenges that need to be addressed to integrate Monero wallet to the Trezor.

Trezor is a hardware second factor, secure token storing wallet secrets in a secure way. 
The Trezor is connected to the host running the software wallet communicating with the Trezor. The software wallet is connected to the full Monero which has stored the whole blockchain. The software wallet is operated by a user, the wallet owner. The wallet shows received and sent transactions, current balance and is used to enter payment information for a new transaction. The outgoing transaction has to be confirmed by a user on the Trezor.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth, angle=0]{trezord.pdf}
	\caption{Environment}
\end{figure}


\subsection{License}
This work is licensed under Apache v2 license in the current version. The license may change in the following revisions.

\subsection{Attacker model}

Trezor device attacker model is the same as with other crypto currencies (e.g., physical device security, memory forensics protection, side channel analysis, fault induction).

The host and the full node are assumed to be fully compromised. An attacker can start multiple instances of protocols, interleave protocol runs, send, replay, delay or drop any messages to/from the Trezor. Attackers goal is to spend user-unconfirmed transaction to his advantage or to cause any damage to the user. As the software wallet is operated from the host there are naturally no privacy guarantees on the host. Compromised host sees all transactions and can naturally block some messages, e.g., incoming transactions. 

In a weaker setting, only the full node is assumed to be fully compromised. The goal of an attacker on the full node is either to spend a victim monero, cause a loss or to learn any information about user's received or sent transactions (e.g., transaction ownership, balance, outgoing transaction addresses).
 
\subsection{Definitions}

\paragraph{Basic system}

\begin{itemize}
	\item $G$ is a base point of the curve $E$ (ed25519) of the order $l$
	\item $H_p : \{0,1\}^* \rightarrow E$, hash function to a curve point
	\item $H_s : \{0,1\}^* \rightarrow [1, l-1]$, hash function to a scalar
	\item $H = H_p(G)$, a point on the curve $E$. It holds $H=hG$, $h$ is unknown
	
\end{itemize}

\paragraph{Transactions}

\begin{itemize}
	\item $(a, B)$ account view-key
	\item $(a, b)$ account spend-key (private scalars)
	\item $(A, B)$ the public wallet address, $A=aG$, $B=bG$
	\item $(C_{i,j}, D_{i,j})$ public sub-address with $i, j$ major minor index resp.
	\begin{enumerate}
		\item $D_{i,j} = B + H_s(a \; || \; i \; || \; j)G$
		\item $C_{i,j} = aD_{i,j}$ 
	\end{enumerate}
	\item A single transactions has zero\footnote{coinbase transaction has zero inputs, coin emission from the mining.} or more inputs; one or more outputs.
	\item $(r, R)$ transaction key-pair. Unique per transaction. 
	\item $(x, P)$ transaction output spend key and an address. Unique per transaction output.
	\begin{enumerate}
		\item $x = H_s(rA) + b$, also called the ephemeral key. Used for spending.
		\item $P = xG = H_s(rA)G + B$, public key stored in the transaction output.
	\end{enumerate}
	\item $aR$ is also called the derivation (ECDH)
\end{itemize}

EC points and scalars occupy 32 B.

There are field names from the JSON transaction representation used in the notation throughout the text.\footnote{Example: \url{https://xmrchain.net/tx/599533a7e42e82aa23c8da1d730fec047915ee5614556883cdce90739f1a94d3/1}}. There are also used variable names used in the Monero code base.

\subsection{Environment}

The basic setup is a Trezor hardware wallet with the account keys and a connected host.

We start with the most straightforward setup:
\begin{itemize}
	\item The host is running a Monero software wallet \verb|monero-wallet-cli|
	
	\item  The software wallet is connected to a Monero full-node (local or trusted remote).
	
	\item The basic wallet operations are performed via \verb|monero-wallet-cli| which is configured to work with the Trezor device.
	
	\item Some of the operations are performed in the Trezor. 
\end{itemize}

Later, also the monero-gui wallet is extended to support the Trezor.

\subsection{Account secrets.}
Account key-pairs are BIP-44 generated from the seed. Spend-key never leaves the device. There are two variants w.r.t. the view-key $a$:

\begin{enumerate}
	\item Performance BC scanning: view-key is exported to the host-based wallet to do blockchain transaction scanning for the wallet.
	\item Private BC scanning: view-key never leaves the device. The wallet synchronization is performed via Trezor. 
\end{enumerate}

All other wallet related data, e.g., outputs with received moneros are
stored in the wallet on the host.

\subsection{Initialization} 
The wallet can be either created from a fresh seed or recovered from an existing seed.

The fresh wallet can be used right-away while the recovered wallet has to rescan the blockchain to detect all incoming transactions since the wallet create-time (if unknown, the whole blockchain).

\section{Blockchain scanning}

In order to receive incoming transfers, the blockchain has to be scanned. A~specific operation has to be performed on each transaction output with the view-key $a$ to determine whether the transaction output is destined to us.

For a received transaction output Tx we have public keys $\left(R, P\right)$.
The wallet computes: 

\begin{equation}
B^\prime = P - H_s(aR)G
\end{equation}


If $\left(B^\prime = B\right) \; \vee \; \left(B^\prime \in \{D_{i,j}\}_{i,j}\right)$, then\footnote{$B^\prime$ is equal to the user's $B$ or one of it's sub-addresses} the transaction output is destined for us. Otherwise it can be ignored by the wallet.

Computation complexity per transaction output: 2x point multiplications, 1x SHA-3, 1x point subtraction.

\subsection{Sub-addresses}
The sub-address is defined by the base address $(A,B)$ and the index tuple $(i,j)$, unsigned 32 bit major and minor index \cite{mrl_006_subaddr}.

\begin{itemize}
	\item The $(C_{i,j}, D_{i,j})$ is sub-address with major index $i$ and the minor index $j$.
	
	\item  The wallet holds mappings $D_{i,j} \rightarrow (i, j)$ and $(i, j) \rightarrow D_{i,j}$. 
	
	\item According to the convention, the master address has indices $(0, 0)$.
	
	\item Public key for sending tsx to sub-address: $P = H_s(rC_{i,j})G + D_{i,j}$
	
	\item Private spending key: $x = H_s(aR \; || \; idx) + b + H_s(a \; || \; i \; || \; j)$, where $idx$ is a real transaction output index in the transaction.
	
	\item The scanning for funds works with the same formula, only one computation is required. See \cite{mrl_006_subaddr} for details.
\end{itemize}

\subsection{Performance scanning} 
The view-key $a$ is exported to the software wallet. For the receiving, no Trezor interaction is needed. 

\noindent Pros:
\begin{itemize}
	\item High-speed synchronization.
	\item Receiving moneros and balance without a need to have Trezor connected.
	\item Only small code changes required in the official Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Privacy loss. Host malware can read all future incoming inputs and the amounts. View-key can leak.
\end{itemize}

\subsection{Private scanning}
The view-key $a$ never leaves the device. The device has to be connected
to perform the wallet refresh. 
Each new transaction has to be sent to the device for the identification.
There are several possible variants with varying complexity and performance.

\subsubsection{Naive approach} One roundtrip per transaction output to determine the ownership. 
\begin{enumerate}
	\item Send $(R, P)$ to the Trezor
	\item Trezor returns $B^\prime$, where $B^\prime = P - H_s(aR)G$
\end{enumerate}

If the host finds a match with $B^\prime$ it performs additional roundtrip to determine the transaction output value for RingCT transactions.

This is the most straightforward approach also suggested in the Ledger proposal \cite{ledger_doc}. The performance can be significantly degraded due to high computation and communication overhead. Although a benchmark would be needed to determine the baseline performance.

In terms of implementation this is a rather simple way as only the low-level operations are proxied to the HW wallet leaving most of the original code intact.

Communication complexity: One round-trip per transaction output. A transaction can have multiple outputs, block contains more transactions so multiple round-trips per one block refresh. The request is 64~B in size, response 32~B.

\subsubsection{Fast batched scanning}
During the wallet refresh the wallet loads missing blocks from the full-node RPC server. Each query yields 1000 blocks at maximum. 

The host wallet sends a batch of transaction outputs to decide the ownership in the Trezor. This part is called a \emph{transaction output identification}.

\begin{enumerate}
	\item Choose a batch size $bt$
	\item Create a list $lst = [(R_k, P_k), (R_{k+1}, P_{k+1}), ...]$ such that $|lst| \leq bt$
	\item Send $lst$ to the Trezor
	\item Initially, Trezor sets $res = []$
	\item Trezor processes each $(R_i, P_i)$. If there is a match, the index is added to the result array $i \rightarrow res$.
	\item Trezor returns $res$ 
\end{enumerate}
Most of the time the Trezor will just return an empty list as there is no new incoming transaction output destined to the account. If the list is not empty then the detailed scanning is performed for each transaction. 

Communication complexity: One message roundtrip per the batch. The request is $64bt$~B in size. The response is maximally $2bt$~B in size while the expected value is close to zero with overwhelming probability. 

\paragraph{Detailed scanning:} In this phase the host wallet sends transaction previously identified as belonging to our account for processing to the Trezor. The whole transaction output is sent to the Trezor so it can extract the amount and the mask from the transaction.

\paragraph{Sub-addresses:}
A wallet can generate independent-looking sub-addresses that are usable for receiving moneros using the same secret keys. Over the time wallet generates and stores multiple sub-addresses. 
For a recovered wallet sub-addresses are pre-computed in advance, $10k$ in total (look-ahead limits $L_M, L_m$, where $L_M=50$ and $L_m=200$ in the current version).
This poses a problem for the private BC scanning on the Trezor if the number of sub-addresses is large as the Trezor needs to decide transaction ownership using the sub-addresses set\footnote{The set of size several thousands of address may be difficult to store in the device}.

There are several workaround variants for the transaction output identification. The request remains the same as in the previous protocol. The batch of $(R_i, P_i)$ per transaction output.

\begin{enumerate}
	\item The Trezor returns a list of results $\left[B^{\prime}_k, B^{\prime}_{k+1}, \dots\right]$ instead of the index list. The decision is then made on the host. Each point has 32 B in size. This variant increases a communication overhead as each transaction output yields $B^{\prime}_i$.
	
	\item The Trezor returns a list similarly as in the previous variant with a difference of sending prefix of the fixed size $p_s$
	$\left[\text{prefix}_{p_s}\left(B^{\prime}_k\right), \text{prefix}_{p_s}\left(B^{\prime}_{k+1}\right), \dots\right]$. Host matches the prefixes with the internal prefix database. If a match is found, transaction is sent for detailed scanning (as before). Trezor might return null as a false positive hit.
	
	\item Trezor builds an internal mapping: $\text{prefix}_{p_s}\left(D_{i,j}\right) \rightarrow \left[(i, j), \dots\right]$.
	If the Trezor finds a prefix match it computes the full sub-address for all matched indices $(i,j)$ to decide false-positive vs. match. Then it returns a list $\left[(idx_1, (i_1, j_1), (idx_2, (i_2, j_2), \dots)\right]$ with all matched results to the host. 
	
	\item Use Bloom filter\footnote{ \url{http://llimllib.github.io/bloomfilter-tutorial/}, \url{https://en.wikipedia.org/wiki/Bloom_filter}} to optimize the storage of the sub-addresses. Bloom filter is a probabilistic data structure for checking the set membership returning results: maybe, no.
	This method enables to balance false positive hits with memory storage. For number of sub-addresses $n=10000$, bit-size of the Bloom filter $m=100000$ the optimal number of hash functions $k=\frac{m}{n}ln2 \approx 7$, false positive probability is roughly $\left(1-e^{-kn/m}\right)^k \approx 0.0084$, $8$ false positives in $1000$ tests with memory requirements $12.5$~kB.
	
\end{enumerate}

\subsubsection{Summary}
Ledger Monero Wallet is using the private blockchain scanning one transaction at a time \cite{ledger_doc}. Without further optimizations, this can be rather slow for the wallet refresh in terms of computations and bandwidth.
We conclude that our improvements (batching) are viable alternatives for privacy-sensitive users.

\noindent Pros:
\begin{itemize}
	\item The view-key $a$ never leaves the device.
	\item $a$ cannot be exfiltrated from the compromised host
	\item The same security-level as the competitor.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Slower wallet synchronization.
	\item Wallet restore could be infeasible as the whole blockchain has to be scanned (or take hours to complete). Benchmark is needed for this.
	\item More code changes required in the existing software wallets to implement the batching. The naive approach can be implemented with minimal changes (proxying $aR$ operation to the device).
	\item Inputs and the amounts still visible on the host.
\end{itemize}

\subsubsection{Extension} In order to increase the privacy we could hide all transaction inputs on the hosts, to protect the balance value. The balance would be visible only on the Trezor device on request.

The extension would complicate the transaction creation a bit. The Trezor would have to work with the (possibly all) inputs when creating a new transaction. The whole transaction would have to be built in the Trezor. This is rather complicated in terms of implementation. Possible challenges: outputs storage (available flash memory on Trezor vs. encryption when stored on the host), secure memory access - protect from access pattern leakage.

\subsection{Updates}

\paragraph{12\textsuperscript{th} Feb 2017:} Performance version is chosen for the blockchain scanning. Privacy version can be implemented later.

\section{Sending a transaction}
Assume we are going to send $xmr$ Moneros to the address $(A_d, B_d)$
Overall, the sending process goes like this (description inspired by Ledger proposal \cite{ledger_doc}):

\begin{enumerate}
	\item Generate a transaction key-pair $(r, R)$
	\item Process a stealth payment ID
	\item Randomly select received non-spend transaction outputs to spend $T_{in}$ covering the $xmr$ + fee.
	\item Find $mixin$ fake outputs\footnote{get\_outs()} for each UTXO\footnote{unspend transaction output} $T_{in}$ to get ring size $mixin + 1$.
	\item Load the transaction information $(P_i, C_i)$, public key (address) and the amount commitment, from the full-node RPC server for the real and fake outputs going to spend.
	\item For each input transaction $T_{in}$:
	\begin{enumerate}
		\item Compute a derivation $\mathcal{D}_{in} = aR_{in}$
		\item Compute an ephemeral tsx spend key $(x_{in}, P_{in})$, \\where $x_{in} = H_s(aR_{in} \; || \; in) + b$
		\item Compute a key image $I_{in} = x_{in}H_p(P_{in})$
	\end{enumerate}
	\item Build the set of output transactions $T_{out}$. Typically there is one transaction to the $(A_d, B_d)$ address.
	\item If input $>$ output + fee, create a change transaction $T_{chx} \rightarrow T_{out}$. 
	\item For each transaction output $T_{out}$:
	\begin{enumerate}
		\item Compute the range proof. Borromean or Bulletproof \cite{monero_1098, borromean, Bnz2017BulletproofsSP}.
		\item Mask the output amount and the commitment mask in the \verb|ecdhInfo|\footnote{\url{https://github.com/monero-project/monero/blob/a9421f78027dbbdfe82420a5c6f7e77eb4c80bf4/src/ringct/rctSigs.cpp\#L688}} with the secret $H_s(aR_{in}\; || \; in)$ denoted as the amount key.
		\item Compute the output commitments: $C = a_mG + xmrH$, where $a_m$ is a randomly generated commitment mask.
	\end{enumerate}
	\item Compute Ring-CT MG for each $T_{in}$ (real + fake inputs).
	\item Submit the transaction.
\end{enumerate}

\paragraph{Observations:}
\begin{enumerate}
    \item The transaction key pair $(r,R)$ should be generated in the Trezor to make sure it is random and not re-used (attacks by crafting $r$ on the host to leak the information). 
	
	\item The $T_{in}$ processing requires private keys - has to be done in Trezor. Trezor could display sum of all inputs. The transaction can be spent with the $x_{in}$, thus it must not be leaked to the host.
	
	\item The change address has to be generated in the Trezor to avoid the change address spoofing by the compromised host (sending a huge change to the attacker in the transaction confirmed by the user).
	
	\item Each transaction output $T_{out}$ and the monero amount has to be manually confirmed on the Trezor to finish the transaction processing.
	
	\item The range proof does not work with any secrets so it can be offloaded to the host. Range proofs are quite expensive operations and take up to 80\% of the whole transaction space\footnote{Bulletproof takes less space}. Implementation in the software wallet is significantly simpler and faster.
	
	\item Output commitments do not require secret keys but the computation is rather simple so can be performed in the Trezor.
	
	\item The final Ring signatures on inputs will be performed in the Trezor.
\end{enumerate}

\paragraph{Ledger comparison.} The Ledger proposal \cite{ledger_doc} goes further with the protocol modification by employing a custom sub-division protocol. Due to a hardware nature of the Ledger Nano S (about 1k RAM) it is not feasible to compute the transaction in the Ledger in one step so a multi-step approach had to be chosen.

The majority of transaction building process is performed in the software wallet while only the low-level crypto operations with the secret keys are performed in the Ledger.  

The sensitive sub-results are returned sealed to the software wallet, encrypted by simple AES/ECB encryption with transaction-specific encryption key, so the sensitive values cannot be used beyond the transaction scope. Ledger has to unseal the inputs, perform the operation and reseal the outputs before returning the result to the wallet. Moreover, to protect the protocol integrity the inputs are hashed in the Ledger. 

\;
\noindent Pros:
\begin{itemize}
	\item Rather simple implementation. The software wallet performs the heavy-lifting while some of the 
	low-level crypto calls are proxied to the Ledger. The sealing is format preserving so no data structures augmentation is needed. Code modifications are small.
	\item Device holds the minimal transaction state.
	\item Abstract device interface in the official Monero code. The plan is to support more HW devices.
	\item The protocol is already designed. We could alleviate an existing PR\cite{ledger_pr} in the Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Protocol design is still evolving. Has not been merged yet.
	\item Sound security analysis of the protocol subdivision is missing. 
	\item The partial protocol can be vulnerable e.g., to change address attacks.
\end{itemize}

\subsection{Signing protocol}

The naive and the most straightforward variant is to adapt the Ledger design. On the other hand, the design is rather new and could be subject to further changes with high probability in the near future. 

Trezor has more resources available for the same job so I suggest doing as maximum as possible on the Trezor to avoid potential vulnerabilities from the protocol subdivision on the low-level.

\subsubsection{Transaction assembly algorithm}

The current version of the Monero software wallet may generate multiple pending transactions while only one is sent eventually in the process of assembling the inputs, outputs and the fee computation (e.g., \emph{wallet2.cpp:6940}\;\verb|goto skip_tx|). The fee is first estimated by a simple formula. However, the serialized transaction blob size is problematic to estimate precisely mainly due to \verb|VARINT_FIELD()|, variable length fields. So the transaction is fully assembled, signed and the real fee is computed as a function of transaction serialized blob. If the computed fee is higher than the  estimated value the transaction is recomputed, the old transaction is discarded. 

One could implement a precise fee computation algorithm but that would duplicate the serialization code which could lead to bugs when the structures are extended in the future. Thus it is easier and safer to build the transaction and then compute the blob size as we have only one code path working with transaction serialization. If serialization changes, the fee computation works without change. 

The software wallet does not have valid wallet keys and we don't want to involve Trezor in this assembly as it would pose unnecessary overhead. The fee computation will be done in the same way as it is now in the software wallet to avoid potentially inducing new bugs. Wallet creates a transaction in the same way but signs it with random account keys. 

Once the algorithm picks a correct transaction to send the user has to confirm all transaction outputs (including the change transaction). Once the transaction is confirmed the transaction is signed with real keys in the Trezor and returned to the wallet. After that, the transaction state is reset.


\subsubsection{High-level protocol description} 
All signatures are performed in the Trezor on the set of spending transaction outputs (TXO) in one step. Output range proofs are offloaded to the host as explained below.

Let $H$ be a cryptographic hash function $H : \{0,1\}^* \rightarrow \{0,1\}^{256}$, preferably Keccak-256 which is already used in the Monero. HMAC uses the hash function $H$. Binary operator $||$ is a binary concatenation.

\paragraph{State:}
Trezor holds a transaction state:
\begin{itemize}
	\item Global transaction counter $c_{tsx}$
	\item Transaction data (inputs, outputs, $(r,R)$, range proofs, signatures, $\dots$)
	\item Transaction cryptographic material: master key $k_{mst}$, base HMAC key $k_{hmac}$
\end{itemize}

\paragraph{Protocol description:}
\begin{enumerate}
	\item $H \rightarrow T$: $TsxData = \text{payment\_id}, \left[\left(T_{out,i}, \text{amount}_i \right), \dots \right]$. Host sends the initial transaction data $TsxData$ to the Trezor by calling\\ InitTransaction$\left(TsxData\right)$.
	
	\begin{enumerate}
		\item $T$: Reset the Trezor transaction state, store $TsxData$.
		
		\item $T$: Generate $(r, R)$, transaction key-pair.
		
		\item $T$: Increment Trezor transaction counter $c_{tsx}$, generate transaction master key $k_{mst} = H(TsxData \; || \; r \; || \; c_{tsx})$.
		
		\item $T$: Generate HMAC key $k_{hmac} = H\left(\text{"hmac"} \; || \; k_{mst}\right)$
	\end{enumerate}
	
	\item $H \rightarrow T$: Set inputs to spend + loaded fakes $T_{in}$. 
	\begin{enumerate}
		\item $T$: For each input: compute derivation $\mathcal{D}_{in}$, ephemeral spending key $x_{in}$, key image $I_{in}$.
	\end{enumerate}
	
	\item $H \rightarrow T$: Set range proofs \emph{asig} for $T_{out}$. Optional, can be computed in the Trezor, may be slower. Useful for Trezor.io (no JS implementation needed).
	\begin{enumerate}
		\item $T$: Store the range proofs.
	\end{enumerate}
	
	\item $H \rightarrow T$: Request the signed transaction $T_{clear}$
	\begin{enumerate}
		\item $T$: Transaction sanity check
		
        \item $T$: Ask the user for confirmation.

		\item $T$: Compute output commitments
		
		\item $T$: Perform RingCT signatures on inputs $T_{in}$ (signs also the transaction prefix (inputs, outs, tsx pub key $R$, outputs range proofs, commitments)) with the $x_{in}$ and the key image $I_{in}$.
	\end{enumerate} 
	
	\item $T \rightarrow H$: Return the signed transaction $T_{clear}$.
\end{enumerate}
%\improvement[inline]{Finish decription}

\subsection{Range proof offloading}
The range proof offloading is mainly motivated by the fact it makes up the significant portion of the transaction (per output) in size. The simplest Monero transactions with only two input and two outputs (change address) have around 
13.2~kB where the range proof constitutes about 12~kB from the total size.\footnote{\url{https://getmonero.org/2017/12/07/Monero-Compatible-Bulletproofs.html}}
 
Range proofs are computationally expensive and not using any account or transaction secrets. Offloading thus poses no additional security risk in the current attacker model. The idea is demonstrated mainly on the Borromean range proofs as they are big, but it also generalizes to the Bulletproof (the same interface). 

The range proof is a zero-knowledge proof that the amount lies in the interval $[0, 2^{64})$ without revealing the amount value\footnote{To protect from a negative overflow which would generate new Monero - required part of confidential transaction mechanism using Pedersen commitments}. Intuitively, the invalid range proof causes only the transaction rejection by the full node without compromising the security.

Range proof is generated by \verb|proveRange()| in \emph{rtcSigs.cpp:298}. The only input value to the function is \verb|const xmr_amount & amount|, the amount. The function returns \verb|rangeSig| structure with the range proof, the mask and the amount commitment. 

\paragraph{Offloading separation.}
The first part of the \verb|proveRange()| function generates random $a_i$ values and computes $C_i$ commitments which are further used to generate range proof signatures. These values will be generated in Trezor to have random values under our control as $a_i$ are used as in the mask computation later. We need to protect the amount commitment and the mask from tampering.

\paragraph{Sending a transaction.}
Let's assume the attacker generates an invalid range proof or a range proof for an invalid amount value. The range proof is included in the overall message hash, the \emph{final\_message}, which is signed by the ringCT signatures. Besides that, the range proof values \emph{asig} are not used in the transaction construction. Thus an invalid range proof does not affect the value commitments. 

The full-node validates the whole transaction once the transaction is received to the pool. It is not possible the transaction with invalid range proof is added to the blockchain. The node signalizes an error and transaction is rejected.

In the attacker model, the host already knows the amount as a legitimate user uses software wallet to enter the amount when sending the transaction the privacy is not lost.

\paragraph{Receiving a transaction.}
In the attacker model, the host can already tamper the range signatures thus offloading does not make any difference.
WLOG assume we are using simple RCT\footnote{Non-simple RCT is a bit smaller in size while usable only if the transaction is of a certain form. This alternative does not affect the range proof.}. The range proof verification function is \verb|verRange()| which is called only in the \\\verb|verRctSimple()|. In the current version only full-nodes do RCT verification during the refresh, not the wallet. If the transaction verification fails, it is ignored.

\paragraph{Memory requirements.} 
The range proof consists of Borromean signature and an array of 32~B commitments $C_i$ with 64 elements, one for each bit in the amount value. The Borromean signature contains: $2$ arrays \emph{s0}, \emph{s1} each with $64$ keys, each 32~B, and one 32~B key. In total, the range proof with commitment takes 6176~B in the raw form per one transaction output.

\paragraph{Bulletproof range proof.} The offloading mechanism is very similar to the Borromean range proof. The random mask is generated in the Trezor. The commitment is recomputed in the Trezor to make sure it was not tampered with (simple computation step with amount and mask). 
However, by switching to Bulletproof the range proof size for 2 outputs is reduced roughly from 12~352~B to 2~500~B as Bulletproof signs all outputs with a single signature. The size increases only logarithmically with respect to the number of output transactions. The offloading is not required with Bulletproof if the number of output transactions is small \cite{Bnz2017BulletproofsSP}.

\subsection{Large transactions}
Simple transactions have roughly around 13.2 kB in size. With range proof offloading it is very easy to compute it completely in the Trezor. The problem can arise if a user wants to spend many small inputs to pay to multiple addresses and/or the mixin size is large, e.g., above 10. This increases memory requirements, once the threshold is reached it is not feasible to compute the transaction in the Trezor.

Please note the output processing has to be finished in order to do a ringCT signature on the TXOs as the signature contains hash of the outputs (range proofs), \emph{final\_message}. Each TXO is ringCT-signed separately. The inputs to the signature are mainly:

\begin{itemize}
	\item \emph{final\_message} hash. Binds the transaction to the TXO signature (see below), has 32~B in size.
    \item Vector of $(P_i, C_i)$, the public keys and the commitments for the transaction inputs. One entry in the index is our TXO to spend; others are decoys / mixins. The size is $(mixin+1) * 64$~B.
	\item Secret spending key $x_{in}$ and the mask $a_i$, together 64~B.
\end{itemize}
The memory requirements for the signature input is $(mixin+1) * 64 + 96$~B in total.

The ring-CT signature per one TXO contains a 32~B key field \emph{cc} and the matrix of 32~B keys called \emph{ss} having $2$ rows and $mixin + 1$ columns. The memory requirements for the output are then $(mixin + 1) * 64 + 32$~B.

\paragraph{Protocol subdivision }

Obviously, the one-step transaction construction may not suffice for large transactions with many inputs and large mixins. Thus in order to support arbitrarily large transactions, the subdivision has to be employed similarly to the Ledger. The proposal is to implement all-in-one approach first, supporting only smaller transactions. In the second phase, the subdivided protocol will be implemented supporting arbitrarily large transactions. The subdivision should undergo a security review before being deployed to the production. In the subdivided approach we will not stick to the Ledger proposal as we can go few levels up compared to the relatively low-level approach of the Ledger subdivision. E.g., compute the whole ringCT for one input in the Trezor. The minimal division unit would be one input/output.

\paragraph{Memory consumption example:}
If the transaction has 30 TXOs with mixin set to 19 the overall memory requirements for inputs are 41~280~B, outputs are 39~360~B. This is the minimal memory needed to do the computation. The signature itself consumes roughly around 128~B of memory per TXO.

\subsection{RingCT MLSAG Signature details}

RingCT signature over the input from $T_{in}$ signs the input values and the message hash \emph{final\_message} binding all transaction data to the input being signed. A part of the \emph{final\_message} is the \emph{transaction\_prefix}:

\begin{lstlisting}[language=c++]
class transaction_prefix {
public:
  size_t   version;
  uint64_t unlock_time;  
  std::vector<txin_v> vin;
  std::vector<tx_out> vout;
  std::vector<uint8_t> extra;
}
\end{lstlisting}

Fields \emph{version}, \emph{unlock\_time} are simple primitive types defining the transaction version and the block-time the transaction can be spent. Fields \emph{vin}, \emph{vout} define all TXO to spend and destinations respectivelly. Field \emph{extra} contains transaction public keys\footnote{More than 1 if sub-addresses are used} and another serialized metadata, such as encrypted payment ID and additional transaction public keys if applicable (sub-addresses).

The transaction outputs \emph{tx\_out} is a tuple \emph{(amount, pub\_key)} for an ordinary outgoing transactions, sent by an user. 

The \emph{txin\_v} is a variant type\footnote{Similar to union, can have one of given types} but WLOG let's assume its type is \emph{txin\_to\_key} which is used with ordinary transactions. 

\begin{lstlisting}[language=c++]
struct txin_to_key {
  uint64_t amount;
  std::vector<uint64_t> key_offsets;
  crypto::key_image k_image;
}
\end{lstlisting}

The \emph{amount} is the real amount of the TXO to spend, even for RingCT transactions. RingCT amounts are zeroed out before the signature is performed to hide the values in the transaction header as it gets to the blockchain. Zeoring is also necessary so third parties can verify the signature as they don't know the amount values for RingCTs.
The vector \emph{key\_offsets} codes the TXO indices in the blockchain. They form a mix set. One of the TXO is our which we can spend; others are decoys.
The \emph{k\_image} is the key image for the mix ring. It depends only on the TXO being spent. Decoy TXOs do not affect key image value, obviously.

\paragraph{Final message hash} The final message hash has the following structure: \emph{final\_message} = \emph{transaction\_prefix} || \emph{rct\_signatures} output transaction data || \emph{rangeSigs} range proofs. Using the notation from the JSON transaction representation. \footnote{Example: \url{https://xmrchain.net/tx/599533a7e42e82aa23c8da1d730fec047915ee5614556883cdce90739f1a94d3/1}}

\paragraph{Security implications}
The fact that RingCT signature signs \emph{final\_message} which includes the \emph{transaction\_prefix} gives quite strong security guarantees. In fact, the signed TXO can be spent only in the context of the given transaction. The signature cannot be re-used for spending in a different transaction as the verification would fail. This protects from the attack where an attacker takes a valid transaction, reassembles it and submits own tampered version instead of the valid one.

Thus if we can build the transaction prefix and its hash securely in the Trezor we can use the protocol subdivision on the transaction inputs, ringCT signing one input TXO at a time with the offloading result to the host. 

\paragraph{Memory requirements}
The \emph{version} and \emph{unlock\_time} take 16 B. The \emph{extra} fields can vary in size, in majority of cases it contains the serialized transaction public key 32~B, the 8~B payment ID. It may contain multiple public keys if sub-addresses are involved. If there is at least one sub-address (and not the only one) in the output transaction, there is an additional public key for each transaction output, 32~B per transaction. Which gives minimally $16 + 32 = 48$~B. In general it may be $56 + \left|T_{out}\right| * 32$~B.

The \emph{vin} takes roughly $(8 + 8 * (mixin + 1) + 32) * \left|T_{in}\right|$~B, ignoring the serialization overhead (tagging, array size encoding). The \emph{vout} takes roughly $(8 + 32) * \left|T_{out}\right|$.

The basic transaction with two inputs and two outputs and mixin 4 takes approximately $56 + (40 + 5*8)*2 + 40*2 = 296$~B. A more advanced case with 100 inputs, 100 outputs, and mixin level 99 yields 88~006~B.  

\subsection{Subdividing output processing}
Assume transaction prefix and its hash is computed in the Trezor.
For an easier description I use the field names used in the JSON transaction representation.\footnote{Example: \url{https://xmrchain.net/tx/599533a7e42e82aa23c8da1d730fec047915ee5614556883cdce90739f1a94d3/1}}

The output transactions are processed one by one. At first, the range proof is generated as described in previous sections. All required fields are computed afterwards i.e., \emph{mask}, \emph{output commitment}, \emph{pseudoOuts}, \emph{ecdhInfo}. 

The \emph{rct\_signatures} structure is held in the Trezor memory and filled in one-by-one with computed transaction output fields. Memory requirements to store the structure are $4 * 32 = 128$~B per transaction output. The structure is used during the \emph{final\_message} hashing - the message signed by an input RingCT signature. The \emph{final\_message} hash is generated by \verb|get_pre_mlsag_hash()|. Unfortunately the structure \emph{rct\_signatures} cannot be hashed incrementally as it hashes all \emph{pseudoOuts} then all \emph{ecdhInfo} and so on.

On the other hand, the \emph{rctsig\_prunable.rangeSigs} structure with the range proofs can be hashed incrementally, one transaction output at a time, so the range proof storage is offloaded to the host and loaded back when needed. To protect the transaction ordering and the integrity of the fields \emph{asig}, \emph{Ci} the blob is HMACed with the key $H(k_{hmac} \; || \; \text{"txoutres"} \; || \; i)$, where $i$ is the index of the outgoing transaction. Once the HMACed data is loaded from the host the HMAC is checked. Thus attacker cannot tamper the data, reorder, reply or drop any output transaction data. During the HMAC verification, the index is computed by the Trezor, so the ordering of the transactions has to be preserved otherwise the HMAC will fail (no replay, reordering or skipping). No other transaction can be added as the HMAC will be invalid. Trezor has to check if none transaction was dropped.

Once all output transactions are computed, the \emph{final\_message} hash is computed. This step finalizes the output processing so the inputs can be signed - the final transaction step.

\subsection{Subdivided protocol overview}

The brief recapitulation of the subdivided protocol:

\begin{enumerate}
	\item Initialize the new protocol run as in the original one step protocol.
	\item $H \rightarrow T$: Send all transaction inputs $T_{in}$, one by one, as \verb|tx_source_entry|.\\
	$T_{in,i} = ((\text{idx}, P_j,C_j)_j, \text{amount}, \text{mask}, \pi, \text{pubs}, \dots)_i$
	\begin{enumerate}
		\item Trezor computes $x_{in}, \mathcal{D}_{in}, I_{in}$. The $x_{in}, \mathcal{D}_{in}$ are stored in the Trezor transaction state.
		
		\item Compute transaction prefix $vin_i$
		
		\item Compute HMAC on the data: HMAC($T_{in,i} \; || \; I_{in} \; || \; vin_i$), HMAC key: $H(k_{hmac} \; || \; \text{"txin"} \; || \; i)$.
		
		\item Return $vin_i$ part.
	\end{enumerate} 
	
	\item $H \rightarrow T$: Send all transaction outputs $T_{out}$, one by one. $T_{out,i} = ((A_d, B_d), \text{amount})_i$
	\begin{enumerate}
		\item Change address for the change transaction $T_{chx}$ is recomputed in the Trezor.
				
		\item Generate the key derivation $\mathcal{D}_{out}$
		\item Derive a transaction output public key $P_{out}$
		\item Compute additional tx public keys $P_{out,j}$ if needed (sub-addresses)
		
        \item Store the derivation $\mathcal{D}_{out}$ in the Trezor transaction state.
        
        \item Compute the transaction prefix $vout_i$ and $extra_i$.
        
        \item HMAC of the output transaction data HMAC($T_{out,i} \; || \; P_{out} \; || \; P_{out,j} \; || \; vout_i \; || \; extra_i $) with HMAC key: $H(k_{hmac} \; || \; \text{"txout"} \; || \; i)$.
		
		\item Return the transaction prefix $vout_i$ and $extra_i$.
		
		\item On the last transaction: The transaction prefix hash is computed and stored to the state.
	\end{enumerate}
	  
	\item $H \rightarrow T$: Send all transaction outputs $T_{out}$, one by one, together with offloaded data (tx pubkey, additional keys). 
	\begin{enumerate}
		\item Check the HMAC
		
		\item Compute the Range proof in the host with randomness generated in Trezor.
		
		\item Compute \emph{mask}, \emph{output commitment}, \emph{ecdhInfo}.
		
		\item Compute the HMAC($asig_i$ || $Ci_i$) with the HMAC key $H(k_{hmac} \; || \; \text{"txoutres"} \; || \; i)$. Store the HMAC to the transaction state.
		
		\item Add data to the \emph{rct\_signatures} structure.
		
		\item Return the \emph{rct\_signatures} update, $asig_i$, $Ci_i$.
	\end{enumerate}

	\item $H \rightarrow T$: Send all transaction outputs $T_{out}$ computed data in the previous step. $asig_i$, $Ci_i$
	\begin{enumerate}
		\item Check the HMAC
		
		\item Hash range proofs incrementally to the \emph{final\_message}
		
		\item On the last transaction store the \emph{final\_message} hash. Check that no transaction was dropped.
	\end{enumerate}

	\item Send all transaction inputs $T_{in}$, one by one.
	\begin{enumerate}
		\item Check the HMAC
		
		\item Compute RingCT MG signature $S_i$ on the input and the \emph{final\_message}.
		
	\end{enumerate} 
	
\end{enumerate}

\paragraph{HMAC verification}
HMAC values are returned with the offloaded data to the host and verified when the offloaded values are loaded back to the Trezor. 
On HMAC failure transaction state is reset and user is notified the error happened.

%The message is generated by function \verb|get_pre_mlsag_hash|.
\subsection{Protocol selection}
The multi-step protocol is a generalization of the one-step version.
If the estimated size of the transaction is below a certain value (depends on $|T_{in}|, |T_{out}|, mixin$) the transaction is computed in one step to minimize the roundtrips. 

Multi-sig is not supported in the first implementation.

\section{Trezor.io}

The more complex integration scenario - trezor.io software wallet.
\begin{enumerate}
	\item Chrome plugin - communication channel to the Trezor device. 
	JS interface to the Trezor. Minimal changes, add new Monero-related messages.
	
	\item Trezor.io Monero RPC node. Full-node local vs. remote node (trusted). A user can run his local node. The node is set in the trezor.io menu. By default, there can be an implicit node owned by the SatoshiLabs or Monero open nodes. So far it seems we don't need blockchain explorer (such as Insight for BTC). The RPC interface of the monero full-node seems enough for the initial version.
	
	\item Basic Monero JS wallet for Trezor.io. Minimalistic for a start. Simple receive + send (spending proofs, etc. can be added later or by the community). 
	
	\item Trezor.io wallet stores transfers, does transaction scanning, wallet refresh, communicates with the full-node (refresh, fake get outs). Range proof could be implemented in the Trezor directly for this case. 
	
	\item Implement Monero crypto in JS. Basic Monero-specific ed25519 operations, SHA-3 based $H_s(), H_p()$.
	
\end{enumerate}


\section{Implementation}

%\improvement[inline]{TODO: Finish}

\noindent TBD. Depends on the further requirements.\\

The implementation process is incremental, start with MVP, minimal viable product. Later extend with more features. MVP has two basic features: 1) receive transactions, view balance, 2) send transaction. 

\begin{enumerate}
	\item Trezor basic Monero-related ed25519 crypto
	\item Transaction specific crypto-material derivation
	\item Monero binary serialization
	\item Monero specific messages for Trezor-Host interface
	\item RingCT and basic transaction primitives
	\item Monero transaction assembly
	\item Extend simplewallet to support Trezor
	\item Monero wallet for Trezor.io 
\end{enumerate}


%\section{Current progress}
%The current state of the work:
%
%\begin{itemize}
%	\item Finishing the feasibility study and the analysis of the Monero and Trezor.
%	\item 
%\end{itemize}


%\improvement[inline]{Add more}

\appendix
\section{Example of Monero transactions}

\lstdefinestyle{jsonStyle}{
	numbers=left,
	stepnumber=1,
	tabsize=4,
	showspaces=false,
	showstringspaces=false
}

\lstset{
	string=[s]{"}{"},
	stringstyle=\color{blue},
	comment=[l]{:},
	commentstyle=\color{black},
	style=jsonStyle
}

Few examples with full json transcript:
\begin{itemize}
	\item \footnotesize\url{https://xmrchain.net/tx/599533a7e42e82aa23c8da1d730fec047915ee5614556883cdce90739f1a94d3/1}
	
	\item \footnotesize\url{https://xmrchain.net/tx/84d09b596cf847eefd5a17ff9eb493e6f33f0a5e601b775e33831cdd6cadf53d/1}
	
	\item \footnotesize\url{https://xmrchain.net/tx/5620d6c7e425ad53d3228f4b70adac0d798915a6d049079a3795dbda5b2b0cce/1}
	
	\item \footnotesize\url{https://xmrchain.net/tx/ae52a85bebaae2a488071aaf0dfbaf143148fd943a8d5f659e2c8ad61e69a318/1}
\end{itemize}

% References
\bibliography{monero}{}
\bibliographystyle{plain}
	
\end{document}

