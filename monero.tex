\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{cite}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

% TODO packages
% https://tex.stackexchange.com/questions/9796/how-to-add-todo-notes
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%opening
\title{Monero wallet Trezor integration draft v0.1}
\author{Du\v{s}an Klinec}

\begin{document}
	
\maketitle

\begin{abstract}
	Design draft of the Monero integration to the Trezor environment and required in Monero codebase changes.
\end{abstract}

\section{Introduction}
Here follows the basic description of the Monero system, environment, and operations that need to be solved to integrate Monero wallet to the Trezor.

\subsection{Definitions}

\paragraph{Basic system}

\begin{itemize}
	\item $G$ is a base point of the curve $E$ (ed25519) of the order $l$
	\item $H_p : \{0,1\}^* \rightarrow E$, hash function to curve point
	\item $H_s : \{0,1\}^* \rightarrow [1, l-1]$, hash function to the scalar
	\item $H = H_p(G)$, a point on the curve $E$. It holds $H=hG$, $h$ is unknown
	
\end{itemize}

\paragraph{Transactions}

\begin{itemize}
	\item $(a, A)$, $(b, B)$ account (sender) view-key / spend-key pair
	\item $(A, B)$ the public wallet address, $A=aG$, $B=bG$
	\item $(C_{i,j}, D_{i,j})$ public sub-address with $i, j$ major minor index
	\begin{enumerate}
		\item $D_{i,j} = B + H_s(a \; || \; i \; || \; j)G$
		\item $C_{i,j} = aD_{i,j}$ 
	\end{enumerate}
	\item $(r, R)$ transaction key-pair. Unique per transaction. 
	\item $(p, P)$ transaction spend key and output address. Unique per transaction output.
	\begin{enumerate}
		\item $p = H_s(aR) + b$, also called ephemeral key. Used for spending.
		\item $P = pG = H_s(aR)G + B$, public key stored in the transaction.
	\end{enumerate}
	\item $aR$ is also called the derivation (ECDH)
\end{itemize}

EC points and scalars ocupy 32 B.

\subsection{Environment}

The basic setup is a Trezor hardware wallet with the account keys and a connected host.

We start with the most straightforward setup:
\begin{itemize}
	\item The host is running a Monero software wallet \verb|monero-wallet-cli|
	
	\item  The software wallet is connected to a Monero full-node (local or trusted remote).
	
	\item The basic wallet operations are performed via \verb|monero-wallet-cli| which is configured to work with the Trezor device.
	
	\item Some of the operations are performed in the Trezor. 
\end{itemize}

Later, also the monero-gui wallet is extended to support the Trezor.

\subsection{Account secrets.}
Account key-pairs are BIP-44 generated from the seed. Spend-key never leaves the device. There are two variants w.r.t. the view-key $a$:

\begin{enumerate}
	\item Performance BC scanning: view-key is exported to the host-based wallet to do blockchain transaction scanning for the wallet.
	\item Private BC scanning: view-key never leaves the device. The wallet synchronization is performed via Trezor. 
\end{enumerate}

All other wallet related data, e.g., outputs with received moneros are
stored in the wallet on the host.

\subsection{Initialization} 
The wallet can be either created from a fresh seed or recovered from the existing seed.

The fresh wallet can be used right-away while the recovered wallet has to rescan the blockchain to detect all incoming transactions from since the wallet create time (if unknown, the whole blockchain).

\section{Blockhain scanning}

In order to receive incoming transfers, the blockchain has to be scanned. A~specific operation has to be performed on each transaction with the view-key $a$ to determine whether the transaction is destined to us.

For a received transaction Tx we have public keys $\left(R, P\right)$.
The wallet computes: 

\begin{equation}
B^\prime = P - H_s(aR)G
\end{equation}


If $\left(B^\prime = B\right) \; \vee \; \left(B^\prime \in \{D_{i,j}\}_{i,j}\right)$, then\footnote{$B^\prime$ is equal to the user's $B$ or one of it's sub-addresses} the transaction is destined for us. Otherwise not and can be ignored by the wallet.

Computation complexity per transaction: 2x point multiplications, 1x SHA-3, 1x point subtraction.

\subsection{Sub-addresses}
The sub-address is defined by the base address $(A,B)$ and the index tuple $(i,j)$, unsigned 32 bit major and minor index \cite{mrl_006_subaddr}.

\begin{itemize}
	\item The $(C_{i,j}, D_{i,j})$ is sub-address with major index $i$ and the minor index $j$.
	
	\item  The wallet holds mappings $D_{i,j} \rightarrow (i, j)$ and $(i, j) \rightarrow D_{i,j}$. 
	
	\item According to the convention, the master address has indices $(0, 0)$.
	
	\item Public key for sending tsx to sub-address: $P = H_s(sC_{i,j})G + D_{i,g}$
	
	\item Private spending key: $p = H_s(aR) + b + H_s(a \; || \; i \; || \; j)$
	
	\item The scanning for funds works with the same formula, only one computation is required. See \cite{mrl_006_subaddr} for details.
\end{itemize}

\subsection{Performance scanning} 
The view-key $a$ is exported to the software wallet. For the receiving, no Trezor interaction is needed. 

\noindent Prons:
\begin{itemize}
	\item High-speed synchronization.
	\item Receiving moneros and balance without a need to have Trezor connected.
	\item Only small code changes required in the official Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Privacy loss. Host malware can read all future incoming inputs and the amounts. View-key can leak.
\end{itemize}

\subsection{Private scanning}
The view-key $a$ never leaves the device. The device has to be connected
to the wallet refresh. 
Each new transaction has to be sent to the device for the identification.
To optimize the performance the following schema is suggested.

\subsubsection{Naive approach} One roundtrip per transaction to determine the transaction ownership. 
\begin{enumerate}
	\item Send $(R, P)$ to the Trezor
	\item Trezor returns $B^\prime$, where $B^\prime = P - H_s(aR)G$
\end{enumerate}

If the host finds a match with $B^\prime$ it performs additional roundtip to determine the transaction output value for RingCT transactions.

This the most straightworard approach is also suggested in the Ledger proposal \cite{ledger_doc}. The performance can be significantly degraded due to high computation and communication overhead. Although a benchmark would be needed to determine the baseline performance.

In terms of implementation this is rather simple way as only the low level operations are forwarded to the HW wallet leaving most of the original code intact.

Communication complexity: One roundtrip per transaction output. Transaction can have multiple outputs, block contains more transactions so multiple transactions per one block refresh. Request is 64~B in size, response 32~B.

\subsubsection{Fast batched scanning}
During the wallet refresh the wallet loads missing blocks from the full-node RPC server. Each query yields 1000 blocks at maximum. 

The host wallet sends a batch of transaction outputs to decide the ownership in the Trezor. This part is called a \emph{transaction output identification}.

\begin{enumerate}
	\item Choose a batch size $bt$
	\item Create a list $lst = [(R_k, P_k), (R_{k+1}, P_{k+1}), ...]$ such that $|lst| \leq bt$
	\item Send $lst$ to the Trezor
	\item Initially, Trezor sets $res = []$
	\item Trezor processes each $(R_i, P_i)$. If there is a match, the index is added to the result array $i \rightarrow res$.
	\item Trezor returns $res$ 
\end{enumerate}
Most of the time the Trezor will just return an empty list as there is no new incoming transaction output destined to the account. If the list is not empty then the detailed scanning is performed for each transaction. 

Communication complexity: One message round trip per the batch. The request is $64bt$~B in size. The response is maximally $2bt$~B in size while the expected value is close to zero with overwhelming probability. 

\paragraph{Detailed scanning:} In this phase the host wallet sends transaction previously identified as belonging to our account for processing to the Trezor. The whole transaction output is sent to the Trezor so it can extract the amount and the mask from the transaction.

\paragraph{Sub-addresses:}
Wallet can generate sub-addresses for others to send moneros to. Over the time wallet generates and stores multiple sub-addresses. 
For a recovered wallet sub-addresses are pre-computed in advance (look-ahead limits $L_M, L_m$)\todo{particular numbers}.
This poses a problem for the private BC scanning on the Trezor if the number of sub-addresses is large as the Trezor needs to decide transaction ownership using the sub-addresses set\footnote{The set of size several thousands of address may be difficult to store in the device}.

There are several workaround variants for the transaction output identification. The request remains the same, the batch of $(R_i, P_i)$ per transaction output.

\begin{enumerate}
	\item The Trezor returns a list of results $\left[B^{\prime}_k, B^{\prime}_{k+1}, \dots\right]$ instead of the index list. The decision is then made on the host. Each point has 32 B in size. This variant increases a communication overhead as each transaction output yields $B^{\prime}_i$.
	
	\item The Trezor returns a list similarly as in the previous variant with a difference of sending prefix of the fixed size $p_s$
	$\left[\text{prefix}_{p_s}\left(B^{\prime}_k\right), \text{prefix}_{p_s}\left(B^{\prime}_{k+1}\right), \dots\right]$. Host matches the prefixes with the internal prefix database. If match is found, transaction is sent for detailed scanning (as before). Trezor might return null as a false positive hit.
	
	\item Trezor builds an internal mapping $\text{prefix}_{p_s}\left(D_{i,j}\right) \rightarrow \left[(i, j), \dots\right]$.
	If the Trezor finds a prefix match it computes the full sub-address for all matched indices $(i,j)$ to decide false-positive vs. match. Then it returns a list $\left[(idx_1, (i_1, j_1), (idx_2, (i_2, j_2), \dots)\right]$ with all matched results to the host. 
	
\end{enumerate}

\subsubsection{Summary}
Ledger Monero Wallet is using the private blockchain scanning by default \cite{ledger_doc}, which is slower in terms of computations and bandwidth. Moreover, it lacks the batching thus we conclude this our improvements are viable alternatives for privacy-sensitive users.

\noindent Prons:
\begin{itemize}
	\item The view-key $a$ never leaves the device.
	\item $a$ cannot be exfiltrated from the compromised host
	\item The same security-level as a competitor.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Slower wallet synchronization.
	\item Wallet restore could be unfeasible as the whole blockchain has to be scanned (or take days to complete). Benchmark is needed for this.
	\item More code changes in the existing software wallets to implement the batching. The naive approach can be implemented with minimal changes (forwarding $aR$ operation to the device).
	\item Inputs and the amounts still visible on the host.
\end{itemize}

\subsubsection{Extension} In order to increase the privacy we could hide all transaction inputs on the hosts, to protect the balance value. The balance would be visible only on the Trezor device on request.

The extension would complicate the transaction creation a bit. The Trezor would have to work with the (possibly all) inputs when creating a new transaction (sending Moneros). The whole transaction would have to be built in the Trezor. This is rather complicated in terms of implementation. 


\section{Sending a transaction}
Assume we are going to send $xmr$ Moneros to the address $(A_d, B_d)$
Overall, the sending process goes like this (description inspired by Ledger proposal \cite{ledger_doc}):

\begin{enumerate}
	\item Generate a tsx key-pair $(r, R)$
	\item Process a stealth payment ID
	\item Find random non-spend outputs $T_{in}$ covering the $xmr$ + fee.
	\item Find fake outputs\footnote{get\_outs()} of the given value as $T_{in}$.
	\item Load the transaction information $(P_i, C_i)$, public key and the value commitment, from the full-node RPC server for the real and fake outputs going to spend.
	\item For each input transaction $T_{in}$:
	\begin{enumerate}
		\item Compute a derivation $\mathcal{D}_{in} = aR_{in}$
		\item Compute an ephemeral tsx spend key $(x_{in}, P_{in})$, \\where $x_{in} = H_s(aR_{in}) + b$
		\item Compute a key image $I_{in} = x_{in}H_p(P_{in})$
	\end{enumerate}
	\item Build the set of output transactions $T_{out}$.
	\item If input $>$ output + fee, create a change transaction $T_{chx} \rightarrow T_{out}$. 
	\item For each transaction output $T_{out}$:
	\begin{enumerate}
		\item Compute the range proof. Borromean or Bulletproof \cite{monero_1098, borromean, Bnz2017BulletproofsSP}.
		\item Mask output amount and the mask in \verb|ecdhInfo| with the secret $H_s(aR_{in})$ denoted the amount key.
		\item Compute the output commitments:\\ 
		$C = a_iG + xmrH$, where $a_i$ is a randomly generated mask.
		\item Compute Ring-CT MG for each $T_{in}$ (real + fake inputs).
	\end{enumerate}
	\item Submit the transaction.
\end{enumerate}

\paragraph{Observations:}
\begin{enumerate}
	\item The transaction key pair $(r,R)$ should be generated in the Trezor to make sure the challenge is random and not re-used (attacks by crafting $r$ on the host to leak the information). 
	
	\item The $T_{in}$ processing requires private keys - has to be done in Trezor. Trezor could display sum of all inputs. The transaction can be spent with the $x_{in}$, must not be leaked to the host.
	
	\item The change address has to be generated in the Trezor to avoid change address spoofing by the compromised host (sending a huge change to the attacker in the transaction confirmed by the user).
	
	\item Each transaction output $T_{out}$ and the monero amount has to be manually confirmed on the Trezor to finish the transaction processing.
	
	\item The range proof does not work with any secrets so it can be offloaded to the host. Rangeproofs are quite expensive operations and take up to 80\% of the whole transaction space\footnote{Bulletproof takes less space}. Implementation in the software wallet is significantly simpler and faster.
	
	\item Output commitments do not require secret keys but the computation is rather simple so can be performed in the Trezor.
	
	\item The final Ring signatures on inputs will be performed in the Trezor.
\end{enumerate}

\paragraph{Ledger comparison.} The Ledge proposal \cite{ledger_doc} goes further with the protocol modification by employing a custom sub-division protocol. Due to hardware nature of the Ledger (about 1k RAM) it is not feasible to compute the transaction in the Ledger in one step so a multi-step approach had to be chosen.

The majority of transaction building process is performed in the software wallet while only the low-level crypto operations with the secret keys are performed in the Ledger.  

The sensitive sub-results are returned sealed to the software wallet, encrypted by simple AES/ECB encryption with transaction specific encryption key, so the sensitive values cannot be used beyond the transaction scope. Ledger has to unseal the inputs, perform the operation and reseal the outputs before returning the result to the wallet. Moreover, to protect the protocol integrity the inputs are hashed in the Ledger. 

\;
\noindent Prons:
\begin{itemize}
	\item Rather simple implementation. The software wallet performs the heavy-lifting while some of the 
	low-level crypto calls are routed to the Ledger. The sealing is somehow format preserving encryption so no data structure augmentation is needed. Code modifications are smaller.
	\item Device holds the minimal transaction state.
	\item Abstract device implementation, proposed protocol. We could alleviate an existing PR\cite{ledger_pr} in the Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Sound security analysis is missing. 
	\item The partial protocol can be vulnerable e.g., to change address attacks.
\end{itemize}

\noindent 

\subsection{Signing protocol}

The naive and the most straightforward variant is to replicate Ledger design. On the other hand the design is quite imature and will be subject to changes with high probability. I am also not convinced by its security. As we have more resources on Trezor I propose to do the whole transaction signature in the Trezor.

The current version of the Monero software wallet may generate multiple pending transactions while only one is sent eventually in a process of assembling the inputs and the fee computation. Without a need to redesign the software wallet logic we propose to generate multiple transactions in a similar fashion while only the one being sent and confirmed by the user will be valid. 

For the sake of preserving the same logic Trezor builds pending transactions which are sealed with the format preserving encryption with per transaction encryption keys. Such sealed transaction looks exactly the same as a valid one in terms of size and data fields, but instead of valid signatures it contains their encrypted versions. 

Once the algorithm picks the correct transaction to send the user has to confirm all transaction outputs (including the change transaction). Once the transaction is confirmed the transaction content is unsealed (decrypted) and the valid transaction is returned. After that the transaction state is reset.

%\begin{enumerate}
%	\item Transaction state (counter, randomness, per tsx encryption key)
%	\item Messages for the communication (tsx inputs)
%	\item Messages for range proof offloading.
%	\item Final transaction send.	
%\end{enumerate}

\subsubsection{Protocol description} High level protocol description.
Trezor stores a transaction state:
\begin{itemize}
	\item Global transaction counter $c_{tsx}$
	\item Transaction data (input, outputs, $(r,R)$, range proofs, signatures, $\dots$)
	\item Transaction master key $k_{mst}$.
	\item Transaction base encryption key $k_{enc}$
	\item Transaction base HMAC key $k_{hmac}$
	\item Sealed transaction HMAC value $tsx_{hmac}$
\end{itemize}

\noindent The protocol:
\begin{enumerate}
	\item $H \rightarrow T$: $TsxData = \left[\left(T_{out,i}, \text{amount}_i, \text{payment\_id}_i\right), \dots \right]$. Send initial transaction data to the Trezor, call InitTransaction$\left(TsxData\right)$.
	
	\begin{enumerate}
		\item $T$: Reset the Trezor transaction state, store $TsxData$.
		
		\item $T$: Generate $(r, R)$, transaction key-pair.
		
		\item $T$: Increment Trezor transaction counter $c_{tsx}$, generate transaction master key $k_{mst} = H(TsxData, r, c_{tsx})$.
		
		\item $T$: Generate base encryption key $k_{enc} = H\left(\text{"enc"} \; || \; k_{mst}\right)$
		
		\item $T$: Generate HMAC key $k_{hmac} = H\left(\text{"hmac"} \; || \; k_{mst}\right)$
	\end{enumerate}
	
	\item $H \rightarrow T$: Set inputs to spend + loaded fakes.
	\begin{enumerate}
		\item $T$: For each input: compute derivation, ephemeral spending key $x_{in}$, key image $I_{in}$.
	\end{enumerate}
	
	\item $H \rightarrow T$: Set range proof for $T_{out}$. Optional, can be computed in the Trezor, may be slower. Useful for Trezor.io (no JS implementation needed).
	\begin{enumerate}
		\item $T$: Store the range proof.
	\end{enumerate}
	
	\item $H \rightarrow T$: Request to get the sealed transaction  $T_{seal}$.
	\begin{enumerate}
		\item Signature fields are encrypted with $k_{enc}$ using AES-256 in CBC mode with $IV = H(r \; || \; \text{fieldIdx})$
		
		\item Compute the HMAC to protect transaction integrity and store it to the state.
		$tsx_{hmac} = \text{HMAC}(T_{seal}, k_{hmac}, \text{SHA-256})$
	\end{enumerate} 

	\item $T \rightarrow H$: Return the sealed transaction $T_{seal}$.
		
	\item $H \rightarrow T$: Request the unsealed transaction.
	\begin{enumerate}
		\item $T$: Ask user for confirmation.
		\item $T$: Verify if $tsx_{hmac} = \text{HMAC}(T_{seal}, k_{hmac}, \text{SHA-256})$.
		\item Decrypt $T_{seal}$ transaction fields.
	\end{enumerate}
	\item $T \rightarrow H$: A valid transaction $T_{clear}$.
	
\end{enumerate}
%\improvement[inline]{Finish decription}


\section{Trezor.io}

The more complex integration scenario description follows.
\begin{enumerate}
	\item Chrome plugin - communication channel to the Trezor device. 
	JS interface to the Trezor. Minimal changes, add new Monero-related messages.
	
	\item Trezor.io Monero RPC node. Full-node local vs. remote node (trusted). User can run his own local node. The node is set in the trezor.io menu. By default there can be implicit node owned by the SatoshiLabs / Monero open nodes.
	
	\item Basic Monero JS wallet for Trezor.io. Minimalistic for start. Simple receive + sending (spending proofs, etc... can be added later or by community). 
	
	\item Trezor.io wallet stores transfers, does transaction scanning, wallet refresh. Range proof, bulletproof could be implemented on the Trezor directly for this case. 
	 
	\item Need to implement Monero crypto in JS. Basic curve ed25519 operations, SHA-3 based $H_s(), H_p()$.
	 
\end{enumerate}

\section{Implementation - simple case}

TBD. 
\improvement[inline]{Finish}

\begin{enumerate}
	\item Incremental, start with MVP, minimal viable product.
	\item Tresor basic Monero related crypto, serialization.
	\item Trezor HW device in Wallet2
	\item Extending tsx generation, move the majority to the Trezor.
	
\end{enumerate}




%\improvement[inline]{Add more}

% References
\bibliography{monero}{}
\bibliographystyle{plain}
	
\end{document}

