\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{cite}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[british,UKenglish,USenglish,english,american]{babel}

% TODO packages
% https://tex.stackexchange.com/questions/9796/how-to-add-todo-notes
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%opening
\title{Monero wallet Trezor integration draft v0.2}
\author{Du\v{s}an Klinec \\{dusan.klinec@gmail.com}}


\begin{document}
	
\maketitle

\begin{abstract}
	Design draft of the Monero integration to the Trezor environment and required in Monero codebase changes.
\end{abstract}

\section{Introduction}
Here follows the basic description of the Monero system, environment, and challenges that need to be addressed to integrate Monero wallet to the Trezor.

Trezor is a hardware second factor, secure token storing wallet secrets in a secure way. 
The trezor is connected to the host running the software wallet communicating with the Trezor. The software wallet is connected to the full Monero which has stored the whole blockchain. The software wallet is operated by an user, the wallet owner. The wallet shows received and sent transactions, current balance and is used to enter a new transaction to pay. The outgoing transaction has to be confirmed on the Trezor.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\textwidth, angle=0]{trezord.pdf}
	\caption{Environment}
\end{figure}


\subsection{Attacker model}

Trezor device attacker model is the same as with other crypto currencies (e.g., physical device security, memory forensics protection, side channel analysis, fault induction).

The host and the full node are assumed to be fully compromised. Attacker can start multiple instances of protocols, interleave messages, send, replay, delay or drop any messages to/from the Trezor. Attackers goal is to spend user-unconfirmed transaction to his advantage. As the software wallet is operated from the host there are naturaly no privacy guarantees on the host. Compromised host sees all transactions.

In a weaker setting only the full node is assumed to be fully compromised. The goal of an attacker on the full node is either to spend a victim monero or to learn information about user received or sent transactions (e.g., transaction ovnership, balance, outgoing transaction addresses).
 
\subsection{Definitions}

\paragraph{Basic system}

\begin{itemize}
	\item $G$ is a base point of the curve $E$ (ed25519) of the order $l$
	\item $H_p : \{0,1\}^* \rightarrow E$, hash function to a curve point
	\item $H_s : \{0,1\}^* \rightarrow [1, l-1]$, hash function to a scalar
	\item $H = H_p(G)$, a point on the curve $E$. It holds $H=hG$, $h$ is unknown
	
\end{itemize}

\paragraph{Transactions}

\begin{itemize}
	\item $(a, A)$, $(b, B)$ account (sender) view-key / spend-key pair
	\item $(A, B)$ the public wallet address, $A=aG$, $B=bG$
	\item $(C_{i,j}, D_{i,j})$ public sub-address with $i, j$ major minor index resp.
	\begin{enumerate}
		\item $D_{i,j} = B + H_s(a \; || \; i \; || \; j)G$
		\item $C_{i,j} = aD_{i,j}$ 
	\end{enumerate}
	\item A single transactions has zero\footnote{coinbase transaction has zero inputs, coin emission from the mining.} or more inputs; one or more outputs.
	\item $(r, R)$ transaction key-pair. Unique per transaction. 
	\item $(p, P)$ transaction output spend key and an address. Unique per transaction output.
	\begin{enumerate}
		\item $p = H_s(aR) + b$, also called the ephemeral key. Used for spending.
		\item $P = pG = H_s(aR)G + B$, public key stored in the transaction output.
	\end{enumerate}
	\item $aR$ is also called the derivation (ECDH)
\end{itemize}

EC points and scalars occupy 32 B.

\subsection{Environment}

The basic setup is a Trezor hardware wallet with the account keys and a connected host.

We start with the most straightforward setup:
\begin{itemize}
	\item The host is running a Monero software wallet \verb|monero-wallet-cli|
	
	\item  The software wallet is connected to a Monero full-node (local or trusted remote).
	
	\item The basic wallet operations are performed via \verb|monero-wallet-cli| which is configured to work with the Trezor device.
	
	\item Some of the operations are performed in the Trezor. 
\end{itemize}

Later, also the monero-gui wallet is extended to support the Trezor.

\subsection{Account secrets.}
Account key-pairs are BIP-44 generated from the seed. Spend-key never leaves the device. There are two variants w.r.t. the view-key $a$:

\begin{enumerate}
	\item Performance BC scanning: view-key is exported to the host-based wallet to do blockchain transaction scanning for the wallet.
	\item Private BC scanning: view-key never leaves the device. The wallet synchronization is performed via Trezor. 
\end{enumerate}

All other wallet related data, e.g., outputs with received moneros are
stored in the wallet on the host.

\subsection{Initialization} 
The wallet can be either created from a fresh seed or recovered from an existing seed.

The fresh wallet can be used right-away while the recovered wallet has to rescan the blockchain to detect all incoming transactions since the wallet create time (if unknown, the whole blockchain).

\section{Blockchain scanning}

In order to receive incoming transfers, the blockchain has to be scanned. A~specific operation has to be performed on each transaction output with the view-key $a$ to determine whether the transaction output is destined to us.

For a received transaction output Tx we have public keys $\left(R, P\right)$.
The wallet computes: 

\begin{equation}
B^\prime = P - H_s(aR)G
\end{equation}


If $\left(B^\prime = B\right) \; \vee \; \left(B^\prime \in \{D_{i,j}\}_{i,j}\right)$, then\footnote{$B^\prime$ is equal to the user's $B$ or one of it's sub-addresses} the transaction output is destined for us. Otherwise it can be ignored by the wallet.

Computation complexity per transaction output: 2x point multiplications, 1x SHA-3, 1x point subtraction.

\subsection{Sub-addresses}
The sub-address is defined by the base address $(A,B)$ and the index tuple $(i,j)$, unsigned 32 bit major and minor index \cite{mrl_006_subaddr}.

\begin{itemize}
	\item The $(C_{i,j}, D_{i,j})$ is sub-address with major index $i$ and the minor index $j$.
	
	\item  The wallet holds mappings $D_{i,j} \rightarrow (i, j)$ and $(i, j) \rightarrow D_{i,j}$. 
	
	\item According to the convention, the master address has indices $(0, 0)$.
	
	\item Public key for sending tsx to sub-address: $P = H_s(rC_{i,j})G + D_{i,j}$
	
	\item Private spending key: $p = H_s(aR) + b + H_s(a \; || \; i \; || \; j)$
	
	\item The scanning for funds works with the same formula, only one computation is required. See \cite{mrl_006_subaddr} for details.
\end{itemize}

\subsection{Performance scanning} 
The view-key $a$ is exported to the software wallet. For the receiving, no Trezor interaction is needed. 

\noindent Pros:
\begin{itemize}
	\item High-speed synchronization.
	\item Receiving moneros and balance without a need to have Trezor connected.
	\item Only small code changes required in the official Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Privacy loss. Host malware can read all future incoming inputs and the amounts. View-key can leak.
\end{itemize}

\subsection{Private scanning}
The view-key $a$ never leaves the device. The device has to be connected
to perform the wallet refresh. 
Each new transaction has to be sent to the device for the identification.
There are several possible variants with varying complexity and performance.

\subsubsection{Naive approach} One roundtrip per transaction output to determine the ownership. 
\begin{enumerate}
	\item Send $(R, P)$ to the Trezor
	\item Trezor returns $B^\prime$, where $B^\prime = P - H_s(aR)G$
\end{enumerate}

If the host finds a match with $B^\prime$ it performs additional roundtip to determine the transaction output value for RingCT transactions.

This is the most straightforward approach also suggested in the Ledger proposal \cite{ledger_doc}. The performance can be significantly degraded due to high computation and communication overhead. Although a benchmark would be needed to determine the baseline performance.

In terms of implementation this is rather simple way as only the low level operations are proxied to the HW wallet leaving most of the original code intact.

Communication complexity: One round-trip per transaction output. Transaction can have multiple outputs, block contains more transactions so multiple round-trips per one block refresh. Request is 64~B in size, response 32~B.

\subsubsection{Fast batched scanning}
During the wallet refresh the wallet loads missing blocks from the full-node RPC server. Each query yields 1000 blocks at maximum. 

The host wallet sends a batch of transaction outputs to decide the ownership in the Trezor. This part is called a \emph{transaction output identification}.

\begin{enumerate}
	\item Choose a batch size $bt$
	\item Create a list $lst = [(R_k, P_k), (R_{k+1}, P_{k+1}), ...]$ such that $|lst| \leq bt$
	\item Send $lst$ to the Trezor
	\item Initially, Trezor sets $res = []$
	\item Trezor processes each $(R_i, P_i)$. If there is a match, the index is added to the result array $i \rightarrow res$.
	\item Trezor returns $res$ 
\end{enumerate}
Most of the time the Trezor will just return an empty list as there is no new incoming transaction output destined to the account. If the list is not empty then the detailed scanning is performed for each transaction. 

Communication complexity: One message round-trip per the batch. The request is $64bt$~B in size. The response is maximally $2bt$~B in size while the expected value is close to zero with overwhelming probability. 

\paragraph{Detailed scanning:} In this phase the host wallet sends transaction previously identified as belonging to our account for processing to the Trezor. The whole transaction output is sent to the Trezor so it can extract the amount and the mask from the transaction.

\paragraph{Sub-addresses:}
Wallet can generate independent-looking sub-addresses that are usable for receiving moneros using the same secret keys. Over the time wallet generates and stores multiple sub-addresses. 
For a recovered wallet sub-addresses are pre-computed in advance, $10k$ in total (look-ahead limits $L_M, L_m$, where $L_M=50$ and $L_m=200$ in the current version).
This poses a problem for the private BC scanning on the Trezor if the number of sub-addresses is large as the Trezor needs to decide transaction ownership using the sub-addresses set\footnote{The set of size several thousands of address may be difficult to store in the device}.

There are several workaround variants for the transaction output identification. The request remains the same as in the previous protocol. The batch of $(R_i, P_i)$ per transaction output.

\begin{enumerate}
	\item The Trezor returns a list of results $\left[B^{\prime}_k, B^{\prime}_{k+1}, \dots\right]$ instead of the index list. The decision is then made on the host. Each point has 32 B in size. This variant increases a communication overhead as each transaction output yields $B^{\prime}_i$.
	
	\item The Trezor returns a list similarly as in the previous variant with a difference of sending prefix of the fixed size $p_s$
	$\left[\text{prefix}_{p_s}\left(B^{\prime}_k\right), \text{prefix}_{p_s}\left(B^{\prime}_{k+1}\right), \dots\right]$. Host matches the prefixes with the internal prefix database. If a match is found, transaction is sent for detailed scanning (as before). Trezor might return null as a false positive hit.
	
	\item Trezor builds an internal mapping: $\text{prefix}_{p_s}\left(D_{i,j}\right) \rightarrow \left[(i, j), \dots\right]$.
	If the Trezor finds a prefix match it computes the full sub-address for all matched indices $(i,j)$ to decide false-positive vs. match. Then it returns a list $\left[(idx_1, (i_1, j_1), (idx_2, (i_2, j_2), \dots)\right]$ with all matched results to the host. 
	
\end{enumerate}

\subsubsection{Summary}
Ledger Monero Wallet is using the private blockchain scanning by default \cite{ledger_doc}, which is slower in terms of computations and bandwidth. Moreover, it lacks the batching thus we conclude that our improvements are viable alternatives for privacy-sensitive users.

\noindent Pros:
\begin{itemize}
	\item The view-key $a$ never leaves the device.
	\item $a$ cannot be exfiltrated from the compromised host
	\item The same security-level as the competitor.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Slower wallet synchronization.
	\item Wallet restore could be infeasible as the whole blockchain has to be scanned (or take hours to complete). Benchmark is needed for this.
	\item More code changes required in the existing software wallets to implement the batching. The naive approach can be implemented with minimal changes (proxying $aR$ operation to the device).
	\item Inputs and the amounts still visible on the host.
\end{itemize}

\subsubsection{Extension} In order to increase the privacy we could hide all transaction inputs on the hosts, to protect the balance value. The balance would be visible only on the Trezor device on request.

The extension would complicate the transaction creation a bit. The Trezor would have to work with the (possibly all) inputs when creating a new transaction (sending Moneros). The whole transaction would have to be built in the Trezor. This is rather complicated in terms of implementation. Challenges: outputs storage (available flash memory on Trezor vs. encryption when stored on host), how are accessed on the host - protect from access pattern leakage.

\subsection{Updates}

\paragraph{12\textsuperscript{th} Feb 2017:} Performance version is chosen for the blockchain scanning. Privacy version can be implemented later.

\section{Sending a transaction}
Assume we are going to send $xmr$ Moneros to the address $(A_d, B_d)$
Overall, the sending process goes like this (description inspired by Ledger proposal \cite{ledger_doc}):

\begin{enumerate}
	\item Generate a tsx key-pair $(r, R)$
	\item Process a stealth payment ID
	\item Find random non-spend outputs $T_{in}$ covering the $xmr$ + fee.
	\item Find fake outputs\footnote{get\_outs()} for $T_{in}$.
	\item Load the transaction information $(P_i, C_i)$, public key (address) and the amount commitment, from the full-node RPC server for the real and fake outputs going to spend.
	\item For each input transaction $T_{in}$:
	\begin{enumerate}
		\item Compute a derivation $\mathcal{D}_{in} = aR_{in}$
		\item Compute an ephemeral tsx spend key $(x_{in}, P_{in})$, \\where $x_{in} = H_s(aR_{in}) + b$
		\item Compute a key image $I_{in} = x_{in}H_p(P_{in})$
	\end{enumerate}
	\item Build the set of output transactions $T_{out}$.
	\item If input $>$ output + fee, create a change transaction $T_{chx} \rightarrow T_{out}$. 
	\item For each transaction output $T_{out}$:
	\begin{enumerate}
		\item Compute the range proof. Borromean or Bulletproof \cite{monero_1098, borromean, Bnz2017BulletproofsSP}.
		\item Mask the output amount and the commitment mask in the \verb|ecdhInfo| with the secret $H_s(aR_{in})$ denoted as the amount key.
		\item Compute the output commitments: $C = a_mG + xmrH$, where $a_m$ is a randomly generated commitment mask.
	\end{enumerate}
	\item Compute Ring-CT MG for each $T_{in}$ (real + fake inputs).
	\item Submit the transaction.
\end{enumerate}

\paragraph{Observations:}
\begin{enumerate}
	\item The transaction key pair $(r,R)$ should be generated in the Trezor to make sure the it is random and not re-used (attacks by crafting $r$ on the host to leak the information). 
	
	\item The $T_{in}$ processing requires private keys - has to be done in Trezor. Trezor could display sum of all inputs. The transaction can be spent with the $x_{in}$, thus it must not be leaked to the host.
	
	\item The change address has to be generated in the Trezor to avoid the change address spoofing by the compromised host (sending a huge change to the attacker in the transaction confirmed by the user).
	
	\item Each transaction output $T_{out}$ and the monero amount has to be manually confirmed on the Trezor to finish the transaction processing.
	
	\item The range proof does not work with any secrets so it can be offloaded to the host. Range proofs are quite expensive operations and take up to 80\% of the whole transaction space\footnote{Bulletproof takes less space}. Implementation in the software wallet is significantly simpler and faster.
	
	\item Output commitments do not require secret keys but the computation is rather simple so can be performed in the Trezor.
	
	\item The final Ring signatures on inputs will be performed in the Trezor.
\end{enumerate}

\paragraph{Ledger comparison.} The Ledger proposal \cite{ledger_doc} goes further with the protocol modification by employing a custom sub-division protocol. Due to a hardware nature of the Ledger Nano S (about 1k RAM) it is not feasible to compute the transaction in the Ledger in one step so a multi-step approach had to be chosen.

The majority of transaction building process is performed in the software wallet while only the low-level crypto operations with the secret keys are performed in the Ledger.  

The sensitive sub-results are returned sealed to the software wallet, encrypted by simple AES/ECB encryption with transaction-specific encryption key, so the sensitive values cannot be used beyond the transaction scope. Ledger has to unseal the inputs, perform the operation and reseal the outputs before returning the result to the wallet. Moreover, to protect the protocol integrity the inputs are hashed in the Ledger. 

\;
\noindent Pros:
\begin{itemize}
	\item Rather simple implementation. The software wallet performs the heavy-lifting while some of the 
	low-level crypto calls are proxied to the Ledger. The sealing is format preserving so no data structures augmentation is needed. Code modifications are small.
	\item Device holds the minimal transaction state.
	\item Abstract device interface in the official Monero code. The plan is to support more HW devices.
	\item The protocol is already designed. We could alleviate an existing PR\cite{ledger_pr} in the Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Protocol design is still evolving. Has not been merged yet.
	\item Sound security analysis of the protocol subdivision is missing. 
	\item The partial protocol can be vulnerable e.g., to change address attacks.
\end{itemize}

\subsection{Signing protocol}

The naive and the most straightforward variant is to adapt the Ledger design. On the other hand, the design is rather new and could be subject to further changes with high probability in the near future. 

Trezor has more resources available for the same job so I suggest to do as maximum as possible on the Trezor to avoid potential vulnerabilities from the protocol subdivision. 

\subsubsection{Transaction assembly}

The current version of the Monero software wallet may generate multiple pending transactions while only one is sent eventually in the process of assembling the inputs, outputs and the fee computation (e.g., \emph{wallet2.cpp:6940}\;\verb|goto skip_tx|). Without a need to redesign the software wallet logic we propose to generate multiple transactions similarly while only the one being sent and confirmed by the user will be valid - in order to do minimal source modifications in the official Monero code which should make PR merge more easy. 

For the sake of preserving the same logic and minimal modifications, Trezor builds pending transactions which are sealed with the format preserving encryption with per-transaction encryption keys. Such sealed transaction looks exactly the same as a valid one in terms of size and data fields which enables to compute the fee exactly. But instead of valid signatures, it contains their encrypted versions. This form leaks no secret information thus the sealed transaction is useless without unsealing.  

Once the algorithm picks the correct transaction to send the user has to confirm all transaction outputs (including the change transaction). Once the transaction is confirmed the transaction content is unsealed (decrypted) and the valid transaction is returned. After that, the transaction state is reset.


\subsubsection{High-level protocol description} 
All signatures are performed in the Trezor on the set of spending TXO in one step. Output range proofs are offloaded to the host as explained below.

Let $H$ be a cryptographic hash function $H : \{0,1\}^* \rightarrow \{0,1\}^{256}$, preferably Keccak-256 which is already used in the Monero. HMAC uses the hash function $H$. Binary operator $||$ is a binary concatenation.

\paragraph{State:}
Trezor holds a transaction state:
\begin{itemize}
	\item Global transaction counter $c_{tsx}$
	\item Transaction data (inputs, outputs, $(r,R)$, range proofs, signatures, $\dots$)
	\item Transaction cryptographic material: master key $k_{mst}$, base encryption key $k_{enc}$, base HMAC key $k_{hmac}$
	\item Sealed transaction HMAC value $tsx_{hmac}$
\end{itemize}

\paragraph{Protocol description:}
\begin{enumerate}
	\item $H \rightarrow T$: $TsxData = \text{payment\_id}, \left[\left(T_{out,i}, \text{amount}_i \right), \dots \right]$. Host sends the initial transaction data $TsxData$ to the Trezor by calling\\ InitTransaction$\left(TsxData\right)$.
	
	\begin{enumerate}
		\item $T$: Reset the Trezor transaction state, store $TsxData$.
		
		\item $T$: Generate $(r, R)$, transaction key-pair.
		
		\item $T$: Increment Trezor transaction counter $c_{tsx}$, generate transaction master key $k_{mst} = H(TsxData \; || \; r \; || \; c_{tsx})$.
		
		\item $T$: Generate base encryption key $k_{enc} = H\left(\text{"enc"} \; || \; k_{mst}\right)$
		
		\item $T$: Generate HMAC key $k_{hmac} = H\left(\text{"hmac"} \; || \; k_{mst}\right)$
	\end{enumerate}
	
	\item $H \rightarrow T$: Set inputs to spend + loaded fakes $T_{in}$.
	\begin{enumerate}
		\item $T$: For each input: compute derivation, ephemeral spending key $x_{in}$, key image $I_{in}$.
	\end{enumerate}
	
	\item $H \rightarrow T$: Set range proofs \emph{asig} for $T_{out}$. Optional, can be computed in the Trezor, may be slower. Useful for Trezor.io (no JS implementation needed).
	\begin{enumerate}
		\item $T$: Store the range proofs.
	\end{enumerate}
	
	\item $H \rightarrow T$: Request the sealed transaction $T_{seal}$
	\begin{enumerate}
		\item $T$: Transaction sanity check

		\item $T$: Compute output commitments
		
		\item $T$: Perform RingCT signatures on inputs $T_{in}$ (signs also the transaction prefix (inputs, outs, tsx pub key $R$, outputs range proofs, commitments)) with the $x_{in}$ and the key image $I_{in}$.
	
		\item $T$: Encrypt signature fields with $k_{enc}$ using AES-256 in CBC mode with $IV = H(r \; || \; \text{fieldIdx})$
		
		\item $T$: Compute the HMAC to protect transaction integrity and store it to the transaction state.
		$tsx_{hmac} = \text{HMAC}_{k_{hmac}}(T_{seal})$
	\end{enumerate} 
	
	\item $T \rightarrow H$: Return the sealed transaction $T_{seal}$.
	
	\item $H \rightarrow T$: Request to unseal the transaction $T_{seal}$.
	\begin{enumerate}
		\item $T$: Verify if $tsx_{hmac} = \text{HMAC}_{k_{hmac}}(T_{seal})$.
		
		\item $T$: Ask the user for a confirmation.

		\item $T$: Decrypt $T_{seal}$ transaction fields.
	\end{enumerate}

	\item $T \rightarrow H$: The valid transaction $T_{clear}$.
	
\end{enumerate}
%\improvement[inline]{Finish decription}

\subsection{Details}




\subsubsection{Transaction sealing}
The sealing is implemented in the first phase to minimize code changes in the official Monero codebase while preserving the security level. 
The benefit of the sealing is that the host can exactly compute transaction fees (based on the transaction blob size) and then ask to unseal the transaction before sending. Trezor does not have to store the whole transaction or rebuild it from the scratch as a simple signature decryption (unsealing) is enough.

Later this can be reimplemented in a way software wallet creates a dummy transaction signed with random keys. This preserves the transaction length so the fee computation is precise. Before the sending Trezor rebuilds the transaction - replaces dummy signatures with the real ones.

\subsubsection{Range proof offloading}
The range proof offloading is mainly motivated by the fact it makes up the significant portion of the transaction (per output) in size, it is computationally expensive and not using any account or transaction secrets. Offloading thus poses no additional security risk in the current attacker model. The idea is demonstrated mainly on the Borromean range proofs as they are big in size but it generalizes also to the Bulletproof (same interface). 

The range proof is a zero-knowledge proof that the amount lies in the interval $[0, 2^{64})$ without revealing the amount value\footnote{To protect from a negative overflow which would generate new Monero - required part of confidential transaction mechanism using Pedersen commitments}. Intuitivelly, the invalid range proof causes only the transaction rejection by the full node without compromising the security.

Range proof is generated by \verb|proveRange()| in \emph{rtcSigs.cpp:298}. The only input value to the function is \verb|const xmr_amount & amount|, the amount. The function returns \verb|rangeSig| structure with the range proof, the mask and the amount commitment. 

\paragraph{Implementation notes.}
The first part of the \verb|proveRange()| function generates random $a_i$ values and $C_i$ which are further used to generate range proof signatures. These values will be generated in Trezor to have random values under our control as $a_i$ are used as a mask later. We need to protect the amount commitment and the mask from tampering.

\paragraph{Sending a transaction.}
Let's assume the attacker generates an invalid range proof or a range proof for invalid amount value. The range proof is included in the overal message hash which sender generates ringCT signatures for but besides that the range proof values are not used in the transaction sending process. Thus invalid range proof does not affect the value commitments. 

The full-node validates the whole transaction on transaction receive to the pool thus it is not possible the transaction with invalid range proof is added to the blockchain. The node signalizes an error and transaction is rejected.

In the attacker model the host already knows the amount as a legitimate user uses software wallet to enter the amount when sending the transaction the privacy is not lost.

\paragraph{Receiving a transaction.}
In the attacker model the host can already tamper the range signatures thus offloading does not make any difference.
WLOG assume we are using simple RCT\footnote{non-simple RCT is a bit smaller in size while usable only if the transaction is of certain form. This alternative does not affect the range proof.}. The range proof verification function is \verb|verRange()| which is called only in the \\\verb|verRctSimple()|. In the current version only full-nodes do RCT verification during the refresh, not the wallet. If the transaction verification fails, it is ignored.

\paragraph{Bulletproof range proof.} The offloading mechanism is very similar to the Borromean range proof. The random mask is generated in the Trezor. The commitment is recomputed in the Trezor to make sure it was not tampered with (simple computation step with amount and mask).



\section{Trezor.io}

The more complex integration scenario - trezor.io software wallet.
\begin{enumerate}
	\item Chrome plugin - communication channel to the Trezor device. 
	JS interface to the Trezor. Minimal changes, add new Monero-related messages.
	
	\item Trezor.io Monero RPC node. Full-node local vs. remote node (trusted). A user can run his local node. The node is set in the trezor.io menu. By default, there can be an implicit node owned by the SatoshiLabs or Monero open nodes. So far it seems we don't need blockchain explorer (such as Insight for BTC). The RPC interface of the monero full-node seems enough for the initial version.
	
	\item Basic Monero JS wallet for Trezor.io. Minimalistic for a start. Simple receive + send (spending proofs, etc. can be added later or by the community). 
	
	\item Trezor.io wallet stores transfers, does transaction scanning, wallet refresh, communicates with the full-node (refresh, fake get outs). Range proof could be implemented in the Trezor directly for this case. 
	
	\item Implement Monero crypto in JS. Basic Monero-specific ed25519 operations, SHA-3 based $H_s(), H_p()$.
	
\end{enumerate}


\section{Implementation}

%\improvement[inline]{TODO: Finish}

\noindent TBD. Depends on the further requirements.\\

The implementation process is incremental, start with MVP, minimal viable product. Later extend with more features. MVP has two basic features: 1) receive transactions, view balance, 2) send transaction. 

\begin{enumerate}
	\item Trezor basic Monero-related ed25519 crypto
	\item Transaction specific crypto-material derivation
	\item Transaction sealing primitives
	\item Monero binary serialization
	\item Monero specific messages for Trezor-Host interface
	\item RingCT and basic transaction primitives
	\item Monero transaction assembly
	\item Extend simplewallet to support Trezor
	\item Monero wallet for Trezor.io 
\end{enumerate}


%\section{Current progress}
%The current state of the work:
%
%\begin{itemize}
%	\item Finishing the feasibility study and the analysis of the Monero and Trezor.
%	\item 
%\end{itemize}


%\improvement[inline]{Add more}

% References
\bibliography{monero}{}
\bibliographystyle{plain}
	
\end{document}

