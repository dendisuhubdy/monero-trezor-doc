\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{cite}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

% TODO packages
% https://tex.stackexchange.com/questions/9796/how-to-add-todo-notes
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%opening
\title{Monero wallet Trezor integration draft v0.1}
\author{Du\v{s}an Klinec}

\begin{document}
	
\maketitle

\begin{abstract}
	Design draft of the Monero integration to the Trezor environment and required in Monero codebase changes.
\end{abstract}

\section{Introduction}
Here follows the basic description of the Monero system, environment, and operations that need to be solved to integrate Monero wallet to the Trezor.

\subsection{Definitions}

\paragraph{Basic system}

\begin{itemize}
	\item $G$ is a base point of the curve $E$ (ed25519) of the order $l$
	\item $H_p : \{0,1\}^* \rightarrow E$, hash function to curve point
	\item $H_s : \{0,1\}^* \rightarrow [1, l-1]$, hash function to the scalar
	\item $H = H_p(G)$, a point on the curve $E$. It holds $H=hG$, $h$ is unknown
	
\end{itemize}

\paragraph{Transactions}

\begin{itemize}
	\item $(a, A)$, $(b, B)$ account (sender) view-key / spend-key pair
	\item $(A, B)$ the public wallet address, $A=aG$, $B=bG$
	\item $(C_{i,j}, D_{i,j})$ public sub-address with $i, j$ major minor index
	\begin{enumerate}
		\item $D_{i,j} = B + H_s(a \; || \; i \; || \; j)G$
		\item $C_{i,j} = aD_{i,j}$ 
	\end{enumerate}
	\item $(r, R)$ transaction key-pair 
	\item $(p, P)$ transaction spend key-pair
	\begin{enumerate}
		\item $p = H_s(aR) + b$, also called ephemeral key. Used for spending.
		\item $P = pG = H_s(aR)G + B$, public key stored in the transaction.
	\end{enumerate}
	\item $aR$ is often called the derivation (ECDH)
\end{itemize}

\subsection{Environment}

The basic setup is a Trezor hardware wallet with the account keys and a connected host.

We start with the most straightforward setup.
\begin{itemize}
	\item The host is running a Monero software wallet \verb|monero-wallet-cli|
	
	\item  The software wallet is connected to a Monero full-node (local or trusted remote).
	
	\item The basic wallet operations are performed via \verb|monero-wallet-cli| which is configured to work with the Trezor device.
	
	\item Some of the operations are performed in the Trezor. 
\end{itemize}

Later, also the monero-gui wallet is extended to support the Trezor.

\paragraph{Account secrets.}
Account key-pairs are BIP-44 generated from the seed. Spend-key never leaves the device.

There are two variants w.r.t. view-key $a$:

\begin{enumerate}
	\item Private BC scanning: view-key never leaves the device. Wallet synchronization is performed via Trezor. 
	\item Performance BC scanning: view-key is exported to the host-based wallet to do blockchain transaction scanning for the wallet.
\end{enumerate}

All other wallet related data, e.g., outputs with received moneros are
stored in the wallet on the host. 

\paragraph{Initialization.} The wallet can be either created from a fresh seed or recovered from the existing seed.

The fresh wallet can be used right-away while the recovered wallet has to rescan the blockchain to detect all incoming transactions from since the wallet create time (if unknown, the whole blockchain).

\section{Blockhain scanning}

In order to receive incoming transfers, the blockchain has to be scanned. A~specific operation has to be performed on each transaction with the view-key $a$ to determine whether the transaction is destined to us.

For a received transaction Tx we have public keys $\left(R, P\right)$.
The wallet computes: 

\begin{equation}
B^\prime = P - H_s(aR)G
\end{equation}

If $B^\prime$ is equal to the user's $B$ or one of it's sub-addresses then the transaction is destined for us. Otherwise not and can be ignored by the wallet.

Complexity: 2 point multiplication, hashing, point subtraction.

\subsection{Performance scanning} 
The view-key $a$ is exported to the software wallet. For the receiving, no Trezor interaction is needed. 

\noindent Prons:
\begin{itemize}
	\item High-speed synchronization.
	\item Receiving moneros and balance without a need to have Trezor connected.
	\item Only small code changes required in the official Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Privacy loss. Host malware can read all future incoming inputs and the amounts. View-key can leak.
\end{itemize}

\subsection{Private scanning}
The view-key $a$ never leaves the device. The device has to be connected
to the wallet refresh. 
Each new transaction has to be sent to the device for the identification.
To optimize the performance the following schema is suggested.

\;
During the wallet refresh the wallet loads missing blocks from the full-node RPC server. Each query yields 1000 blocks at maximum. 

\paragraph{Fast batched scanning:}
\begin{enumerate}
	\item Choose a batch size $bt$
	\item Create a list $lst = [(R_k, P_k), (R_{k+1}, P_{k+1}), ...]$ such that $|lst| \leq bt$
	\item Send $lst$ to the Trezor
	\item Initially Trezor sets $res = []$
	\item Trezor processes each $(R_i, P_i)$. If there is a match, the index $i \rightarrow res$ is added to the result array.
	\item Trezor returns $res$ 
\end{enumerate}
Most of the time the Trezor will just return an empty list $[]$ as there is no new incoming transaction destined to the account. 

If the list is not empty then the detailed scanning is performed for each transaction

\paragraph{Detailed scanning:} In this phase the host wallet sends transaction previously identified as belonging to our account for processing to the Trezor. The whole transaction output is sent to the Trezor so it can extract the amount and the mask from the transaction.

\paragraph{Summary:}
The similar mode of operation is also proposed by the Ledger Monero Wallet \cite{ledger_doc}, which is slower in terms of computations and bandwidth. Moreover, lack the batching thus we conclude this is mode is also a viable alternative for more privacy-sensitive users.

\noindent Prons:
\begin{itemize}
	\item The view-key $a$ never leaves the device.
	\item $a$ cannot be exfiltrated from the compromised host
	\item The same security-level as a competitor.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Slower wallet synchronization.
	\item Wallet restore could be unfeasible as the whole blockchain has to be scanned (or take days to complete). Benchmark is needed for this.
	\item More code changes in the existing software wallets to implement the batching. Without batching it could be implemented with minimal changes (forwarding $aR$ operation to the device).
	\item Inputs and the amounts still visible on the host.
\end{itemize}

\paragraph{Extension} In order to increase the privacy we could hide all transaction inputs on the hosts, to protect the balance value. The balance would be visible only on the Trezor device on request.

The extension would complicate the transaction creation a bit. The Trezor would have to work with the (possibly all) inputs when creating a new transaction (sending Moneros). The whole transaction would have to be built in the Trezor. This is rather complicated in terms of implementation. 

\subsection{Sub-addresses}
Initially only the master wallet will be supported with the future sub-address support in mind \cite{mrl_006_subaddr}.

The sub-address is defined by the base address $(A,B)$ and the index tuple $(i,j)$, unsigned 32 bit major and minor index.

\begin{itemize}
	\item The $(C_{i,j}, D_{i,j})$ is sub-address with major index $i$ and the minor index $j$.
	
	\item  The wallet holds mappings $D_{i,j} \rightarrow (i, j)$ and $(i, j) \rightarrow D_{i,j}$. 
	
	\item According to the convention, the master address has indices $(0, 0)$.
	
	\item Public key for sending tsx to sub-address: $P = H_s(sC_{i,j})G + D_{i,g}$
	
	\item Private spending key: $p = H_s(aR) + b + H_s(a \; || \; i \; || \; j)$
	
	\item The scanning for funds works with the same formula, only one computation is required. See \cite{mrl_006_subaddr} for details.
\end{itemize}


\paragraph{Privacy scanning.}
The sub-addresses are precomputed in advanced in large numbers (look-ahead limits). 
This poses a problem for the private BC scanning on the Trezor as it needs to identify whether the result of the operation belongs to the sub-addresses set or not. The set of size several thousands of address may be difficult to store on the device.

Trezor does not have to store the whole $D_{i,j} \rightarrow (i, j)$ mapping but stores only a fixed prefix of $D_{i,j}$ such as: 
$prefix(D_{i,j}, preflen) \rightarrow [(i, j), \dots]$. When a match is found the Trezor can compute sub-addresses for all matched indices to decide false positive vs. hit, with possible LRU caching.


\section{Sending a transaction}
Assume we are going to send $xmr$ Moneros to the address $(A_d, B_d)$
Overall, the sending process goes like this (description inspired by Ledger proposal \cite{ledger_doc}):

\begin{enumerate}
	\item Generate a tsx key-pair $(r, R)$
	\item Process a stealth payment ID
	\item Find random non-spend outputs $T_{in}$ covering the $xmr$ + fee.
	\item Find fake outputs\footnote{get\_outs()} of the given value as $T_{in}$.
	\item Load the transaction information $(P_i, C_i)$, public key and the value commitment, from the full-node RPC server for the real and fake outputs going to spend.
	\item For each input transaction $T_{in}$:
	\begin{enumerate}
		\item Compute a derivation $\mathcal{D}_{in} = aR_{in}$
		\item Compute an ephemeral tsx spend key $(x_{in}, P_{in})$, \\where $x_{in} = H_s(aR_{in}) + b$
		\item Compute a key image $I_{in} = x_{in}H_p(P_{in})$
	\end{enumerate}
	\item Build the set of output transactions $T_{out}$
	\item If input $>$ output + fee, create a change transaction $T_{chx} \in T_{out}$. 
	\begin{enumerate}
		\item Compute the range proof. Borromean or Bulletproof \cite{monero_1098, Bnz2017BulletproofsSP}.
		\item Mask output amount and the mask in \verb|ecdhInfo| with the secret $H_s(aR_{in})$ denoted the amount key.
		\item Compute the output commitments:\\ 
		$C = a_iG + xmrH$, where $a_i$ is a mask.
		\item Compute Ring-CT MG for each $T_{in}$ (real + fake inputs)
	\end{enumerate}
	\item Submit the transaction
\end{enumerate}

\paragraph{Observations:}
\begin{enumerate}
	\item The transaction key pair $(r,R)$ should be generated in the Trezor to make sure the challenge is random (attacks by crafting $r$ on the host to leak the information). 
	
	\item The input processing requires private keys - has to be done in Trezor. Trezor could display sum of all inputs. The transaction can be spent with the $x_{in}$, must not be leaked to the host.
	
	\item The change address has to be generated in the Trezor to avoid crafting change address by the compromised host (sending a huge change to the attacker). Change address cannot be confirmed easily - is random.
	
	\item Each Output + monero amount has to be manually confirmed on the Trezor to finish transaction processing.
	
	\item The range proof does not work with any secrets so it can be offloaded to the host. Rangeproofs are quite expensive operations and take up to 80\% of the whole transaction space\footnote{Bulletproof is simpler}. Implementation in the software wallet is significantly simpler and faster.
	
	\item Output commitments do not require secret keys but the computation is rather simple so can be performed in the Trezor.
	
	\item The final Ring signatures on inputs will be performed in the Trezor.
\end{enumerate}

\paragraph{Ledger comparison.} The Ledge proposal \cite{ledger_doc} goes further with the protocol modification by employing a custom sub-division protocol. Due to hardware nature of the Ledger (about 1k RAM) it is not feasible to compute the transaction in the Ledger in one step so a multi-step approach had to be chosen.

The majority of transaction building process is performed in the software wallet while only the low-level crypto operations with the secret keys are performed in the Ledger.  

The sensitive sub-results are returned sealed to the hardware wallet, encrypted by simple AES/ECB encryption with transaction specific encryption key, so the sensitive values cannot be used beyond the transaction scope. Ledger has to unseal the inputs, perform the operation and reseal the outputs before returning the result to the wallet. Moreover, to protect the protocol integrity the inputs are hashed. 

\;
\noindent Prons:
\begin{itemize}
	\item Rather simple implementation. The software wallet performs the heavy-lifting while some of the 
	low-level crypto calls are routed to the Ledger. The sealing is somehow format preserving encryption so no data structure augmentation is needed. Code modifications are smaller.
	\item Device holds the minimal transaction state.
	\item Abstract device implementation, proposed protocol. We could alleviate an existing PR\cite{ledger_pr} in the Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Thoughtful security analysis is missing. 
	\item The partial protocol can be vulnerable e.g., to change address attacks.
\end{itemize}

\noindent 

\subsection{Signing protocol}

\begin{enumerate}
	\item Transaction state (counter, randomness, per tsx encryption key)
	\item Messages for the communication (tsx inputs)
	\item Messages for range proof offloading.
	\item Final transaction send.	
\end{enumerate}

\paragraph{Protocol description}
\begin{enumerate}
	\item InitTransaction$( [(T_{out,i}, \text{amount}_i, \text{payment\_id}_i), \dots])$. Send initial transaction info to the Trezor.
	
	\item T: Reset transaction state, store new tsx data.
	
	\item T: Generate $(r, R)$
	
	\item T: Generate transaction random challenge $sec$, increase tsx counter. Send $(H(sec), tsx_i)$ to the host. \todo{Maybe needed later for tsx identification?}
	
	\item Set inputs + fakes.
	
	\item Set range proof for $T_{out}$. Optional, can be computed in the Trezor, may be slower. Useful for Trezor.io (no JS implementation needed).
	
	\item Get signed transaction ready for broadcast.
	

\end{enumerate}
\improvement[inline]{Finish decription}

\section{Trezor.io}

The more complex integration scenario description follows.
\begin{enumerate}
	\item Chrome plugin - communication channel to the Trezor device. 
	JS interface to the Trezor. Minimal changes, add new Monero-related messages.
	
	\item Trezor.io Monero RPC node. Full-node local vs. remote node (trusted). User can run his own local node. The node is set in the trezor.io menu. By default there can be implicit node owned by the SatoshiLabs / Monero open nodes.
	
	\item Basic Monero JS wallet (quite a lot of work). Simple receive + sending. Minimalistic for start.
	
	\item Trezor.io wallet. Stores transfers, does transaction scanning, wallet refresh. Range proof, bulletproof could be implemented on the Trezor directly for this case. 
	 
	\item Need to implement Monero crypto in JS. Basic curve ed25519 operations, SHA-3 based $H_s(), H_p()$.
	 
\end{enumerate}

\section{Implementation - simple case}

\begin{enumerate}
	\item Tresor basic Monero related crypto, serialization.
	\item Trezor HW device in Wallet2
	\item Extending tsx generation, move the majority to the Trezor.
	
\end{enumerate}




%\improvement[inline]{Add more}

% References
\bibliography{monero}{}
\bibliographystyle{plain}
	
\end{document}

