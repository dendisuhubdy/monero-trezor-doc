\documentclass[]{article}
\usepackage{cite}
\usepackage{url}
\usepackage{amsmath}

% TODO packages
% https://tex.stackexchange.com/questions/9796/how-to-add-todo-notes
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage[pdftex,dvipsnames]{xcolor}  % Coloured text etc.
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}

%opening
\title{Monero wallet Trezor integration}
\author{Du\v{s}an Klinec}

\begin{document}
	
\maketitle

\begin{abstract}
	Design of the Monero integration to the Trezor environment and required in Monero codebase changes.
\end{abstract}

\section{Introduction}
Here follows the basic description of the Monero system, environment, and operations that need to be solved to integrate Monero wallet to the Trezor.

\subsection{Definitions}

\paragraph{Basic system}

\begin{itemize}
	\item $G$ is a base point of the curve $E$ (ed25519) of the order $l$
	\item $H_p : \{0,1\}^* \rightarrow E$, hash function to curve point
	\item $H_s : \{0,1\}^* \rightarrow [1, l-1]$, hash function to the scalar
	\item $H = H_p(G)$, a point on the curve $E$. It holds $H=hG$, $h$ is unknown
	
\end{itemize}

\paragraph{Transactions}

\begin{itemize}
	\item $(a, A)$, $(b, B)$ account (sender) view-key / spend-key pair
	\item $(r, R)$ transaction key-pair 
	\item $(p, P)$ transaction spend key-pair
	\begin{itemize}
		\item $p = H_s(aR) + b$, also called ephemeral key. Used for spending.
		\item $P = pG = H_s(aR)G + B$, public key stored in the transaction.
	\end{itemize}
	\item $aR$ is often called the derivation (ECDH)
\end{itemize}

\subsection{Environment}

The basic setup is a Trezor wallet with the account keys and connected host with the Monero software wallet.

We start with the most straightforward setup, \verb|monero-wallet-cli|. Software wallet is connected to a Monero full-node (local or trusted remote).

\paragraph{Account secrets.}
Account key-pairs are BIP-44 generated from the seed. Spend-key never leaves the device.

There are two variants w.r.t. view-key $a$:

\begin{enumerate}
	\item private scanning: view-key never leaves the device. Wallet synchronization is performed via Trezor. 
	\item Performance scanning: view-key is exported to the host-based wallet to do blockchain transaction scanning for the wallet.
\end{enumerate}

All other wallet related data, e.g., outputs with received moneros are
stored in the wallet on the host. 

\paragraph{Initialization.} The wallet can be either created from a fresh seed or recovered from the existing seed.

The fresh wallet can be used right-away while the recovered wallet has to rescan the blockchain to detect all incoming transactions from since the wallet create time (if unknown, the whole blockchain).

\section{Blockhain scanning}

In order to receive incoming transfers, the blockchain has to be scanned. A~specific operation has to be performed on each transaction with the view-key $a$ to determine whether the transaction is destined to us.

For a received transaction Tx we have $\left(R, P\right)$.
Wallet computes: 

\begin{equation}
B^\prime = P - H_s(aR)G
\end{equation}

If $B^\prime$ is equal to the user's $B$ or one of it's sub-addresses then the transaction is destined for us. Otherwise not and can be ignored by the wallet.

Complexity: 2 point multiplication, hashing, point subtraction.

\subsection{Performance scanning} 
The view-key $a$ is exported to the software wallet. For the receiving, no Trezor interaction is needed. 

\noindent Prons:
\begin{itemize}
	\item High-speed synchronization.
	\item Receiving moneros and balance without a need to have Trezor connected.
	\item Only small code changes required in the official Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Privacy loss. Host malware can read all future incoming inputs and the amounts. View-key can leak.
\end{itemize}

\subsection{Private scanning}
The view-key $a$ never leaves the device. The device has to be connected
to the wallet refresh. 
Each new transaction has to be sent to the device for the identification.
To optimize the performance the following schema is suggested.

\;
During the wallet refresh the wallet loads missing blocks from the full-node RPC server. Each query yields 1000 blocks at maximum. 

\paragraph{Fast batched scanning:}
\begin{enumerate}
	\item Choose a batch size $bt$
	\item Create a list $lst = [(R_k, P_k), (R_{k+1}, P_{k+1}), ...]$ such that $|lst| \leq bt$
	\item Send $lst$ to the Trezor
	\item Initially Trezor sets $res = []$
	\item Trezor processes each $(R_i, P_i)$. If there is a match, the index $i \rightarrow res$ is added to the result array.
	\item Trezor returns $res$ 
\end{enumerate}
Most of the time the Trezor will just return an empty list $[]$ as there is no new incoming transaction destined to the account. 

If the list is not empty then the detailed scanning is performed for each transaction

\paragraph{Detailed scanning:} In this phase the host wallet sends transaction previously identified as belonging to our account for processing to the Trezor. The whole transaction output is sent to the Trezor so it can extract the amount and the mask from the transaction.

\paragraph{Summary:}
The similar mode of operation is also proposed by the Ledger Monero Wallet \cite{ledger_doc}, which is slower in terms of computations and bandwidth. Moreover, lack the batching thus we conclude this is mode is also a viable alternative for more privacy-sensitive users.

\noindent Prons:
\begin{itemize}
	\item The view-key $a$ never leaves the device.
	\item $a$ cannot be exfiltrated from the compromised host
	\item The same security-level as a competitor.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Slower wallet synchronization.
	\item Wallet restore could be unfeasible as the whole blockchain has to be scanned (or take days to complete). Benchmark is needed for this.
	\item More code changes in the existing software wallets to implement the batching. Without batching it could be implemented with minimal changes (forwarding $aR$ operation to the device).
	\item Inputs and the amounts still visible on the host.
\end{itemize}

\paragraph{Extension} In order to increase the privacy we could hide all transaction inputs on the hosts, to protect the balance value. The balance would be visible only on the Trezor device on request.

The extension would complicate the transaction creation a bit. The Trezor would have to work with the (possibly all) inputs when creating a new transaction (sending Moneros). The whole transaction would have to be built in the Trezor. This is rather complicated in terms of implementation. 


\section{Sending a transaction}
Assume we are going to send $xmr$ Moneros to the address $(A_d, B_d)$
Overall, the sending process goes like this (description inspired by Ledger proposal \cite{ledger_doc}):

\begin{enumerate}
	\item Generate a tsx key-pair $(r, R)$
	\item Process a stealth payment ID
	\item Find random non-spend outputs $T_{in}$ covering the $xmr$ + fee.
	\item Find fake outputs\footnote{get\_outs()} of the given value as $T_{in}$.
	\item Load the transaction information $(P_i, C_i)$, public key and the value commitment, from the full-node RPC server for the real and fake outputs going to spend.
	\item For each input transaction $T_{in}$:
	\begin{enumerate}
		\item Compute a derivation $\mathcal{D}_{in} = aR_{in}$
		\item Compute an ephemeral tsx spend key $(x_{in}, P_{in})$, \\where $x_{in} = H_s(aR_{in}) + b$
		\item Compute a key image $I_{in} = x_{in}H_p(P_{in})$
	\end{enumerate}
	\item Build the set of output transactions $T_{out}$
	\item If input $>$ output + fee, create a change transaction $T_{chx} \in T_{out}$. 
	\begin{enumerate}
		\item Compute the range proof. Borromean or Bulletproof \cite{monero_1098, Bnz2017BulletproofsSP}.
		\item Mask output amount and the mask in \verb|ecdhInfo| with the secret $H_s(aR_{in})$ denoted the amount key.
		\item Compute the output commitments:\\ 
		$C = a_iG + xmrH$, where $a_i$ is a mask.
		\item Compute Ring-CT MG for each $T_{in}$ (real + fake inputs)
	\end{enumerate}
	\item Submit the transaction
\end{enumerate}

\paragraph{Observations:}
\begin{enumerate}
	\item The transaction key pair $(r,R)$ should be generated in the Trezor to make sure the challenge is random (attacks by crafting $r$ on the host to leak the information). 
	
	\item The input processing requires private keys - has to be done in Trezor. Trezor could display sum of all inputs. The transaction can be spent with the $x_{in}$, must not be leaked to the host.
	
	\item The change address has to be generated in the Trezor to avoid crafting change address by the compromised host (sending a huge change to the attacker). Change address cannot be confirmed easily - is random.
	
	\item Each Output + monero amount has to be manually confirmed on the Trezor to finish transaction processing.
	
	\item The range proof does not work with any secrets so it can be offloaded to the host. Rangeproofs are quite expensive operations and take up to 80\% of the whole transaction space\footnote{Bulletproof is simpler}. Implementation in the software wallet is significantly simpler and faster.
	
	\item Output commitments do not require secret keys but the computation is rather simple so can be performed in the Trezor.
	
	\item The final Ring signatures on inputs will be performed in the Trezor.
\end{enumerate}

\paragraph{Ledger comparison.} The Ledge proposal \cite{ledger_doc} goes further with the protocol modification by employing a custom sub-division protocol. Due to hardware nature of the Ledger (about 1k RAM) it is not feasible to compute the transaction in the Ledger so another partial approach had to be chosen.

The majority of transaction building process is performed in the software wallet while only the low-level crypto operations with the secret keys are performed on the Ledger.  

The sensitive sub-results are returned sealed to the hardware wallet, encrypted by simple AES/ECB encryption with transaction specific encryption key, so the sensitive values cannot be used beyond the transaction scope. Ledger has to unseal the inputs, perform the operation and reseal the outputs before returning the result to the wallet. Moreover, to protect the protocol integrity the inputs are hashed. 

\;
\noindent Prons:
\begin{itemize}
	\item Rather simple implementation. The software wallet performs the heavy-lifting while some of the 
	low-level crypto calls are routed to the Ledger. The sealing is somehow format preserving encryption so no data structure augmentation is needed. Code modifications are smaller.
	\item Device holds the minimal transaction state.
	\item Abstract device implementation, proposed protocol. We could alleviate an existing PR\cite{ledger_pr} in the Monero wallet.
\end{itemize}

\noindent Cons:
\begin{itemize}
	\item Thoughtful security analysis is missing. 
	\item The partial protocol can be vulnerable e.g., to change address attacks.
\end{itemize}

\noindent 

\subsection{Signing protocol}

\begin{enumerate}
	\item Transaction state (counter, randomness, per tsx encryption key)
	\item Messages for the communication (tsx inputs)
	\item Messages for range proof offloading.
	\item Final transaction send.
\end{enumerate}
\improvement[inline]{Describe}

\section{Trezor.io}

The more complex integration scenario description follows.
\begin{enumerate}
	\item Full-node local vs. remote node (trusted).
	\item Monero JS wallet - quite a lot of work. Simple receive + sending. Minimalistic for start.
	\item Monero simplewallet RPC server - would have to be locally running.
\end{enumerate}

\section{Implementation}

\begin{enumerate}
	\item Tresor basic Monero related crypto, serialization.
	\item Trezor HW device in Wallet2
	\item Extending tsx generation, move the majority to the Trezor.
\end{enumerate}




%\improvement[inline]{Add more}

% References
\bibliography{monero}{}
\bibliographystyle{plain}
	
\end{document}

